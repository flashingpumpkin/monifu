<html>
      <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <title id="title">
          /Users/alex/Projects/org.monifu/monifu/shared/src/main/scala/monifu/reactive/Observable.scala.html
        </title>
        <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap.min.css"/>
        <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
        <script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.3/js/bootstrap.min.js"></script>
        <script src="http://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.18.3/addons/pager/jquery.tablesorter.pager.min.js"></script>
        <style>
          table.codegrid { font-family: monospace; font-size: 12px; width: auto!important; }table.statementlist { width: auto!important; font-size: 13px; } table.codegrid td { padding: 0!important; border: 0!important } table td.linenumber { width: 40px!important; } 
        </style>
      </head>
      <body style="font-family: monospace;">
        <ul class="nav nav-tabs">
          <li>
            <a href="#codegrid" data-toggle="tab">Codegrid</a>
          </li>
          <li>
            <a href="#statementlist" data-toggle="tab">Statement List</a>
          </li>
        </ul>
        <div class="tab-content">
          <div class="tab-pane active" id="codegrid">
            <pre style='font-size: 12pt; font-family: courier;'>1 <span style=''>/*
</span>2 <span style=''> * Copyright (c) 2014-2015 Alexandru Nedelcu
</span>3 <span style=''> *
</span>4 <span style=''> * Licensed under the Apache License, Version 2.0 (the "License");
</span>5 <span style=''> * you may not use this file except in compliance with the License.
</span>6 <span style=''> * You may obtain a copy of the License at
</span>7 <span style=''> *
</span>8 <span style=''> *     http://www.apache.org/licenses/LICENSE-2.0
</span>9 <span style=''> *
</span>10 <span style=''> * Unless required by applicable law or agreed to in writing, software
</span>11 <span style=''> * distributed under the License is distributed on an "AS IS" BASIS,
</span>12 <span style=''> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
</span>13 <span style=''> * See the License for the specific language governing permissions and
</span>14 <span style=''> * limitations under the License.
</span>15 <span style=''> */
</span>16 <span style=''>
</span>17 <span style=''>package monifu.reactive
</span>18 <span style=''>
</span>19 <span style=''>import java.io.PrintStream
</span>20 <span style=''>import monifu.concurrent.cancelables.BooleanCancelable
</span>21 <span style=''>import monifu.concurrent.{Cancelable, Scheduler}
</span>22 <span style=''>import monifu.reactive.Ack.{Cancel, Continue}
</span>23 <span style=''>import monifu.reactive.BufferPolicy.{default => defaultPolicy}
</span>24 <span style=''>import monifu.reactive.observers._
</span>25 <span style=''>import monifu.reactive.subjects.{AsyncSubject, BehaviorSubject, PublishSubject, ReplaySubject}
</span>26 <span style=''>import org.reactivestreams.{Publisher, Subscriber => RSubscriber}
</span>27 <span style=''>
</span>28 <span style=''>import scala.concurrent.duration.FiniteDuration
</span>29 <span style=''>import scala.concurrent.{Future, Promise}
</span>30 <span style=''>import scala.language.implicitConversions
</span>31 <span style=''>import scala.util.control.NonFatal
</span>32 <span style=''>
</span>33 <span style=''>
</span>34 <span style=''>/**
</span>35 <span style=''> * Asynchronous implementation of the Observable interface
</span>36 <span style=''> */
</span>37 <span style=''>trait Observable[+T] { self =>
</span>38 <span style=''>  /**
</span>39 <span style=''>   * Characteristic function for an `Observable` instance,
</span>40 <span style=''>   * that creates the subscription and that eventually starts the streaming of events
</span>41 <span style=''>   * to the given [[Observer]], being meant to be overridden in custom combinators
</span>42 <span style=''>   * or in classes implementing Observable.
</span>43 <span style=''>   */
</span>44 <span style=''>  protected def subscribeFn(subscriber: Subscriber[T]): Unit
</span>45 <span style=''>
</span>46 <span style=''>  /**
</span>47 <span style=''>   * Creates the subscription and that starts the stream.
</span>48 <span style=''>   *
</span>49 <span style=''>   * @param observer is an [[monifu.reactive.Observer Observer]] on which `onNext`, `onComplete` and `onError`
</span>50 <span style=''>   *                 happens, according to the Monifu Rx contract.
</span>51 <span style=''>   */
</span>52 <span style=''>  def subscribe(observer: Observer[T])(implicit s: Scheduler): BooleanCancelable = {
</span>53 <span style=''>    val cancelable = </span><span style='background: #AEF1AE'>BooleanCancelable()</span><span style=''>
</span>54 <span style=''>    </span><span style='background: #AEF1AE'>takeWhileNotCanceled(cancelable).unsafeSubscribe(SafeObserver[T](observer))</span><span style=''>
</span>55 <span style=''>    cancelable
</span>56 <span style=''>  }
</span>57 <span style=''>
</span>58 <span style=''>  /**
</span>59 <span style=''>   * Creates the subscription and starts the stream.
</span>60 <span style=''>   */
</span>61 <span style=''>  def subscribe(nextFn: T => Future[Ack], errorFn: Throwable => Unit, completedFn: () => Unit)
</span>62 <span style=''>      (implicit s: Scheduler): BooleanCancelable = {
</span>63 <span style=''>
</span>64 <span style=''>    </span><span style='background: #AEF1AE'>subscribe(new Observer[T] {
</span>65 <span style=''></span><span style='background: #AEF1AE'>      def onNext(elem: T) = nextFn(elem)
</span>66 <span style=''></span><span style='background: #AEF1AE'>      def onComplete() = completedFn()
</span>67 <span style=''></span><span style='background: #AEF1AE'>      def onError(ex: Throwable) = errorFn(ex)
</span>68 <span style=''></span><span style='background: #AEF1AE'>    })</span><span style=''>
</span>69 <span style=''>  }
</span>70 <span style=''>
</span>71 <span style=''>  /**
</span>72 <span style=''>   * Creates the subscription and starts the stream.
</span>73 <span style=''>   */
</span>74 <span style=''>  def subscribe(nextFn: T => Future[Ack], errorFn: Throwable => Unit)(implicit s: Scheduler): BooleanCancelable =
</span>75 <span style=''>    </span><span style='background: #F0ADAD'>subscribe(nextFn, errorFn, () => ())</span><span style=''>
</span>76 <span style=''>
</span>77 <span style=''>  /**
</span>78 <span style=''>   * Creates the subscription and starts the stream.
</span>79 <span style=''>   */
</span>80 <span style=''>  def subscribe()(implicit s: Scheduler): Cancelable =
</span>81 <span style=''>    </span><span style='background: #AEF1AE'>subscribe(elem => Continue)</span><span style=''>
</span>82 <span style=''>
</span>83 <span style=''>  /**
</span>84 <span style=''>   * Creates the subscription and starts the stream.
</span>85 <span style=''>   */
</span>86 <span style=''>  def subscribe(nextFn: T => Future[Ack])(implicit s: Scheduler): BooleanCancelable =
</span>87 <span style=''>    </span><span style='background: #AEF1AE'>subscribe(nextFn, error => s.reportFailure(error), () => ())</span><span style=''>
</span>88 <span style=''>
</span>89 <span style=''>  /**
</span>90 <span style=''>   * Creates the subscription that eventually starts the stream.
</span>91 <span style=''>   *
</span>92 <span style=''>   * This function is "unsafe" to call because it does not protect the calls to the
</span>93 <span style=''>   * given [[Observer]] implementation in regards to unexpected exceptions that
</span>94 <span style=''>   * violate the contract, therefore the given instance must respect its contract
</span>95 <span style=''>   * and not throw any exceptions when the observable calls `onNext`,
</span>96 <span style=''>   * `onComplete` and `onError`. if it does, then the behavior is undefined.
</span>97 <span style=''>   *
</span>98 <span style=''>   * @param observer is an [[monifu.reactive.Observer Observer]] that respects
</span>99 <span style=''>   *                 Monifu Rx contract.
</span>100 <span style=''>   */
</span>101 <span style=''>  def unsafeSubscribe(observer: Observer[T])(implicit s: Scheduler): Unit = {
</span>102 <span style=''>    </span><span style='background: #AEF1AE'>subscribeFn(Subscriber(observer, s))</span><span style=''>
</span>103 <span style=''>  }
</span>104 <span style=''>
</span>105 <span style=''>  /**
</span>106 <span style=''>   * Creates the subscription that eventually starts the stream.
</span>107 <span style=''>   *
</span>108 <span style=''>   * This function is "unsafe" to call because it does not protect the calls to the
</span>109 <span style=''>   * given [[Observer]] implementation in regards to unexpected exceptions that
</span>110 <span style=''>   * violate the contract, therefore the given instance must respect its contract
</span>111 <span style=''>   * and not throw any exceptions when the observable calls `onNext`,
</span>112 <span style=''>   * `onComplete` and `onError`. if it does, then the behavior is undefined.
</span>113 <span style=''>   */
</span>114 <span style=''>  def unsafeSubscribe(subscriber: Subscriber[T]): Unit = {
</span>115 <span style=''>    </span><span style='background: #AEF1AE'>subscribeFn(subscriber)</span><span style=''>
</span>116 <span style=''>  }
</span>117 <span style=''>
</span>118 <span style=''>  /**
</span>119 <span style=''>   * Wraps this Observable into a `org.reactivestreams.Publisher`.
</span>120 <span style=''>   */
</span>121 <span style=''>  def publisher[U >: T](implicit s: Scheduler): Publisher[U] =
</span>122 <span style=''>    </span><span style='background: #AEF1AE'>new</span><span style=''> Publisher[U] {
</span>123 <span style=''>      def subscribe(subscriber: RSubscriber[_ >: U]): Unit = {
</span>124 <span style=''>        </span><span style='background: #AEF1AE'>subscribeFn(Subscriber(SafeObserver(Observer.from(subscriber)), s))</span><span style=''>
</span>125 <span style=''>      }
</span>126 <span style=''>    }
</span>127 <span style=''>
</span>128 <span style=''>  /**
</span>129 <span style=''>   * Returns an Observable that applies the given function to each item emitted by an
</span>130 <span style=''>   * Observable and emits the result.
</span>131 <span style=''>   *
</span>132 <span style=''>   * @param f a function to apply to each item emitted by the Observable
</span>133 <span style=''>   * @return an Observable that emits the items from the source Observable, transformed by the given function
</span>134 <span style=''>   */
</span>135 <span style=''>  def map[U](f: T => U): Observable[U] =
</span>136 <span style=''>    </span><span style='background: #AEF1AE'>operators.map(self)(f)</span><span style=''>
</span>137 <span style=''>
</span>138 <span style=''>  /**
</span>139 <span style=''>   * Returns an Observable which only emits those items for which the given predicate holds.
</span>140 <span style=''>   *
</span>141 <span style=''>   * @param p a function that evaluates the items emitted by the source Observable,
</span>142 <span style=''>   *          returning `true` if they pass the filter
</span>143 <span style=''>   *
</span>144 <span style=''>   * @return an Observable that emits only those items in the original Observable
</span>145 <span style=''>   *         for which the filter evaluates as `true`
</span>146 <span style=''>   */
</span>147 <span style=''>  def filter(p: T => Boolean): Observable[T] =
</span>148 <span style=''>    </span><span style='background: #AEF1AE'>operators.filter(self)(p)</span><span style=''>
</span>149 <span style=''>
</span>150 <span style=''>  /**
</span>151 <span style=''>   * Returns an Observable by applying the given partial function to the source observable
</span>152 <span style=''>   * for each element for which the given partial function is defined.
</span>153 <span style=''>   *
</span>154 <span style=''>   * Useful to be used instead of a filter & map combination.
</span>155 <span style=''>   *
</span>156 <span style=''>   * @param pf the function that filters and maps the resulting observable
</span>157 <span style=''>   * @return an Observable that emits the transformed items by the given partial function
</span>158 <span style=''>   */
</span>159 <span style=''>  def collect[U](pf: PartialFunction[T, U]): Observable[U] =
</span>160 <span style=''>    </span><span style='background: #AEF1AE'>operators.collect(self)(pf)</span><span style=''>
</span>161 <span style=''>
</span>162 <span style=''>  /**
</span>163 <span style=''>   * Creates a new Observable by applying a function that you supply to each item emitted by
</span>164 <span style=''>   * the source Observable, where that function returns an Observable, and then concatenating those
</span>165 <span style=''>   * resulting Observables and emitting the results of this concatenation.
</span>166 <span style=''>   *
</span>167 <span style=''>   * @param f a function that, when applied to an item emitted by the source Observable, returns an Observable
</span>168 <span style=''>   * @return an Observable that emits the result of applying the transformation function to each
</span>169 <span style=''>   *         item emitted by the source Observable and concatenating the results of the Observables
</span>170 <span style=''>   *         obtained from this transformation.
</span>171 <span style=''>   */
</span>172 <span style=''>  def flatMap[U](f: T => Observable[U]): Observable[U] =
</span>173 <span style=''>    </span><span style='background: #AEF1AE'>map(f).flatten</span><span style=''>
</span>174 <span style=''>
</span>175 <span style=''>  /**
</span>176 <span style=''>   * Creates a new Observable by applying a function that you supply to each item emitted by
</span>177 <span style=''>   * the source Observable, where that function returns an Observable, and then concatenating those
</span>178 <span style=''>   * resulting Observables and emitting the results of this concatenation.
</span>179 <span style=''>   *
</span>180 <span style=''>   * It's an alias for [[Observable.concatMapDelayError]].
</span>181 <span style=''>   *
</span>182 <span style=''>   * @param f a function that, when applied to an item emitted by the source Observable, returns an Observable
</span>183 <span style=''>   * @return an Observable that emits the result of applying the transformation function to each
</span>184 <span style=''>   *         item emitted by the source Observable and concatenating the results of the Observables
</span>185 <span style=''>   *         obtained from this transformation.
</span>186 <span style=''>   */
</span>187 <span style=''>  def flatMapDelayError[U](f: T => Observable[U]): Observable[U] =
</span>188 <span style=''>    </span><span style='background: #AEF1AE'>map(f).concatDelayError</span><span style=''>
</span>189 <span style=''>
</span>190 <span style=''>  /**
</span>191 <span style=''>   * Creates a new Observable by applying a function that you supply to each item emitted by
</span>192 <span style=''>   * the source Observable, where that function returns an Observable, and then concatenating those
</span>193 <span style=''>   * resulting Observables and emitting the results of this concatenation.
</span>194 <span style=''>   *
</span>195 <span style=''>   * @param f a function that, when applied to an item emitted by the source Observable, returns an Observable
</span>196 <span style=''>   * @return an Observable that emits the result of applying the transformation function to each
</span>197 <span style=''>   *         item emitted by the source Observable and concatenating the results of the Observables
</span>198 <span style=''>   *         obtained from this transformation.
</span>199 <span style=''>   */
</span>200 <span style=''>  def concatMap[U](f: T => Observable[U]): Observable[U] =
</span>201 <span style=''>    </span><span style='background: #F0ADAD'>map(f).concat</span><span style=''>
</span>202 <span style=''>
</span>203 <span style=''>  /**
</span>204 <span style=''>   * Creates a new Observable by applying a function that you supply to each item emitted by
</span>205 <span style=''>   * the source Observable, where that function returns an Observable, and then concatenating those
</span>206 <span style=''>   * resulting Observables and emitting the results of this concatenation.
</span>207 <span style=''>   *
</span>208 <span style=''>   * It's like [[Observable.concatMap]], except that the created observable is reserving onError
</span>209 <span style=''>   * notifications until all of the merged Observables complete and only then passing it along
</span>210 <span style=''>   * to the observers.
</span>211 <span style=''>   *
</span>212 <span style=''>   * @param f a function that, when applied to an item emitted by the source Observable, returns an Observable
</span>213 <span style=''>   * @return an Observable that emits the result of applying the transformation function to each
</span>214 <span style=''>   *         item emitted by the source Observable and concatenating the results of the Observables
</span>215 <span style=''>   *         obtained from this transformation.
</span>216 <span style=''>   */
</span>217 <span style=''>  def concatMapDelayError[U](f: T => Observable[U]): Observable[U] =
</span>218 <span style=''>    </span><span style='background: #F0ADAD'>map(f).concatDelayError</span><span style=''>
</span>219 <span style=''>
</span>220 <span style=''>  /**
</span>221 <span style=''>   * Creates a new Observable by applying a function that you supply to each item emitted by
</span>222 <span style=''>   * the source Observable, where that function returns an Observable, and then merging those
</span>223 <span style=''>   * resulting Observables and emitting the results of this merger.
</span>224 <span style=''>   *
</span>225 <span style=''>   * @param f a function that, when applied to an item emitted by the source Observable, returns an Observable
</span>226 <span style=''>   * @return an Observable that emits the result of applying the transformation function to each
</span>227 <span style=''>   *         item emitted by the source Observable and merging the results of the Observables
</span>228 <span style=''>   *         obtained from this transformation.
</span>229 <span style=''>   */
</span>230 <span style=''>  def mergeMap[U](f: T => Observable[U]): Observable[U] =
</span>231 <span style=''>    </span><span style='background: #AEF1AE'>map(f).merge()</span><span style=''>
</span>232 <span style=''>
</span>233 <span style=''>  /**
</span>234 <span style=''>   * Creates a new Observable by applying a function that you supply to each item emitted by
</span>235 <span style=''>   * the source Observable, where that function returns an Observable, and then merging those
</span>236 <span style=''>   * resulting Observables and emitting the results of this merger.
</span>237 <span style=''>   *
</span>238 <span style=''>   * It's like [[Observable.mergeMap]], except that the created observable is reserving onError
</span>239 <span style=''>   * notifications until all of the merged Observables complete and only then passing it along
</span>240 <span style=''>   * to the observers.
</span>241 <span style=''>   *
</span>242 <span style=''>   * @param f a function that, when applied to an item emitted by the source Observable, returns an Observable
</span>243 <span style=''>   * @return an Observable that emits the result of applying the transformation function to each
</span>244 <span style=''>   *         item emitted by the source Observable and merging the results of the Observables
</span>245 <span style=''>   *         obtained from this transformation.
</span>246 <span style=''>   */
</span>247 <span style=''>  def mergeMapDelayError[U](f: T => Observable[U]): Observable[U] =
</span>248 <span style=''>    </span><span style='background: #AEF1AE'>map(f).mergeDelayError()</span><span style=''>
</span>249 <span style=''>
</span>250 <span style=''>  /**
</span>251 <span style=''>   * Flattens the sequence of Observables emitted by the source into one Observable, without any
</span>252 <span style=''>   * transformation.
</span>253 <span style=''>   *
</span>254 <span style=''>   * It's an alias for [[Observable.concat]].
</span>255 <span style=''>   *
</span>256 <span style=''>   * @return an Observable that emits items that are the result of flattening the items emitted
</span>257 <span style=''>   *         by the Observables emitted by `this`
</span>258 <span style=''>   */
</span>259 <span style=''>  def flatten[U](implicit ev: T <:< Observable[U]): Observable[U] =
</span>260 <span style=''>    </span><span style='background: #AEF1AE'>concat</span><span style=''>
</span>261 <span style=''>
</span>262 <span style=''>  /**
</span>263 <span style=''>   * Flattens the sequence of Observables emitted by the source into one Observable, without any
</span>264 <span style=''>   * transformation. Delays errors until the end.
</span>265 <span style=''>   *
</span>266 <span style=''>   * It's an alias for [[Observable.concatDelayError]].
</span>267 <span style=''>   *
</span>268 <span style=''>   * @return an Observable that emits items that are the result of flattening the items emitted
</span>269 <span style=''>   *         by the Observables emitted by `this`
</span>270 <span style=''>   */
</span>271 <span style=''>  def flattenDelayError[U](implicit ev: T <:< Observable[U]): Observable[U] =
</span>272 <span style=''>    </span><span style='background: #F0ADAD'>concatDelayError</span><span style=''>
</span>273 <span style=''>
</span>274 <span style=''>  /**
</span>275 <span style=''>   * Concatenates the sequence of Observables emitted by the source into one Observable, without any
</span>276 <span style=''>   * transformation.
</span>277 <span style=''>   *
</span>278 <span style=''>   * You can combine the items emitted by multiple Observables so that they act like a single
</span>279 <span style=''>   * Observable by using this method.
</span>280 <span style=''>   *
</span>281 <span style=''>   * The difference between [[concat]] and [[Observable!.merge merge]] is
</span>282 <span style=''>   * that `concat` cares about ordering of emitted items (e.g. all items emitted by the first observable
</span>283 <span style=''>   * in the sequence will come before the elements emitted by the second observable), whereas `merge`
</span>284 <span style=''>   * doesn't care about that (elements get emitted as they come). Because of back-pressure applied to observables,
</span>285 <span style=''>   * [[concat]] is safe to use in all contexts, whereas [[merge]] requires buffering.
</span>286 <span style=''>   *
</span>287 <span style=''>   * @return an Observable that emits items that are the result of flattening the items emitted
</span>288 <span style=''>   *         by the Observables emitted by `this`
</span>289 <span style=''>   */
</span>290 <span style=''>  def concat[U](implicit ev: T <:< Observable[U]): Observable[U] =
</span>291 <span style=''>    </span><span style='background: #AEF1AE'>operators.flatten.concat(self, delayErrors = false)</span><span style=''>
</span>292 <span style=''>
</span>293 <span style=''>  /**
</span>294 <span style=''>   * Concatenates the sequence of Observables emitted by the source into one Observable, without any
</span>295 <span style=''>   * transformation.
</span>296 <span style=''>   *
</span>297 <span style=''>   * It's like [[Observable.concat]], except that the created observable is reserving onError
</span>298 <span style=''>   * notifications until all of the merged Observables complete and only then passing it along
</span>299 <span style=''>   * to the observers.
</span>300 <span style=''>   *
</span>301 <span style=''>   * @return an Observable that emits items that are the result of flattening the items emitted
</span>302 <span style=''>   *         by the Observables emitted by `this`
</span>303 <span style=''>   */
</span>304 <span style=''>  def concatDelayError[U](implicit ev: T <:< Observable[U]): Observable[U] =
</span>305 <span style=''>    </span><span style='background: #AEF1AE'>operators.flatten.concat(self, delayErrors = true)</span><span style=''>
</span>306 <span style=''>
</span>307 <span style=''>  /**
</span>308 <span style=''>   * Merges the sequence of Observables emitted by the source into one Observable, without any
</span>309 <span style=''>   * transformation.
</span>310 <span style=''>   *
</span>311 <span style=''>   * You can combine the items emitted by multiple Observables so that they act like a single
</span>312 <span style=''>   * Observable by using this method.
</span>313 <span style=''>   *
</span>314 <span style=''>   * The difference between [[concat]] and [[merge]] is that `concat` cares about ordering of
</span>315 <span style=''>   * emitted items (e.g. all items emitted by the first observable in the sequence will come before
</span>316 <span style=''>   * the elements emitted by the second observable), whereas `merge` doesn't care about that
</span>317 <span style=''>   * (elements get emitted as they come). Because of back-pressure applied to observables,
</span>318 <span style=''>   * [[concat]] is safe to use in all contexts, whereas [[merge]] requires buffering.
</span>319 <span style=''>   *
</span>320 <span style=''>   * @param bufferPolicy the policy used for buffering, useful if you want to limit the buffer size and
</span>321 <span style=''>   *                     apply back-pressure, trigger and error, etc... see the
</span>322 <span style=''>   *                     available [[monifu.reactive.BufferPolicy buffer policies]].
</span>323 <span style=''>   *
</span>324 <span style=''>   * @return an Observable that emits items that are the result of flattening the items emitted
</span>325 <span style=''>   *         by the Observables emitted by `this`
</span>326 <span style=''>   */
</span>327 <span style=''>  def merge[U](bufferPolicy: BufferPolicy[U] = defaultPolicy)
</span>328 <span style=''>      (implicit ev: T <:< Observable[U]): Observable[U] =
</span>329 <span style=''>    </span><span style='background: #AEF1AE'>operators.flatten.merge(self, bufferPolicy, delayErrors = false)</span><span style=''>
</span>330 <span style=''>
</span>331 <span style=''>  /**
</span>332 <span style=''>   * Merges the sequence of Observables emitted by the source into one Observable, without any
</span>333 <span style=''>   * transformation. You can combine the items emitted by multiple Observables so that they act
</span>334 <span style=''>   * like a single Observable by using this method.
</span>335 <span style=''>   *
</span>336 <span style=''>   * It's like [[Observable.merge]], except that the created observable is reserving onError
</span>337 <span style=''>   * notifications until all of the merged Observables complete and only then passing it along
</span>338 <span style=''>   * to the observers.
</span>339 <span style=''>   *
</span>340 <span style=''>   * @param bufferPolicy the policy used for buffering, useful if you want to limit the buffer size and
</span>341 <span style=''>   *                     apply back-pressure, trigger and error, etc... see the
</span>342 <span style=''>   *                     available [[monifu.reactive.BufferPolicy buffer policies]].
</span>343 <span style=''>   *
</span>344 <span style=''>   * @return an Observable that emits items that are the result of flattening the items emitted
</span>345 <span style=''>   *         by the Observables emitted by `this`
</span>346 <span style=''>   */
</span>347 <span style=''>  def mergeDelayError[U](bufferPolicy: BufferPolicy[U] = defaultPolicy)
</span>348 <span style=''>      (implicit ev: T <:< Observable[U]): Observable[U] =
</span>349 <span style=''>    </span><span style='background: #AEF1AE'>operators.flatten.merge(self, bufferPolicy, delayErrors = true)</span><span style=''>
</span>350 <span style=''>
</span>351 <span style=''>  /**
</span>352 <span style=''>   * Given the source observable and another `Observable`, emits all of the items
</span>353 <span style=''>   * from the first of these Observables to emit an item and cancel the other.
</span>354 <span style=''>   */
</span>355 <span style=''>  def ambWith[U >: T](other: Observable[U]): Observable[U] = {
</span>356 <span style=''>    </span><span style='background: #F0ADAD'>Observable.amb(self, other)</span><span style=''>
</span>357 <span style=''>  }
</span>358 <span style=''>
</span>359 <span style=''>  /**
</span>360 <span style=''>   * Emit items from the source Observable, or emit a default item if
</span>361 <span style=''>   * the source Observable completes after emitting no items.
</span>362 <span style=''>   */
</span>363 <span style=''>  def defaultIfEmpty[U >: T](default: U): Observable[U] =
</span>364 <span style=''>    </span><span style='background: #AEF1AE'>operators.misc.defaultIfEmpty(self, default)</span><span style=''>
</span>365 <span style=''>
</span>366 <span style=''>  /**
</span>367 <span style=''>   * Selects the first ''n'' elements (from the start).
</span>368 <span style=''>   *
</span>369 <span style=''>   *  @param  n  the number of elements to take
</span>370 <span style=''>   *  @return    a new Observable that emits only the first ''n'' elements from the source
</span>371 <span style=''>   */
</span>372 <span style=''>  def take(n: Int): Observable[T] =
</span>373 <span style=''>    </span><span style='background: #AEF1AE'>operators.take.left(self, n)</span><span style=''>
</span>374 <span style=''>
</span>375 <span style=''>  /**
</span>376 <span style=''>   * Creates a new Observable that emits the events of the source, only
</span>377 <span style=''>   * for the specified `timestamp`, after which it completes.
</span>378 <span style=''>   *
</span>379 <span style=''>   * @param timespan the window of time during which the new Observable
</span>380 <span style=''>   *                 is allowed to emit the events of the source
</span>381 <span style=''>   */
</span>382 <span style=''>  def take(timespan: FiniteDuration): Observable[T] =
</span>383 <span style=''>    </span><span style='background: #AEF1AE'>operators.take.leftByTimespan(self, timespan)</span><span style=''>
</span>384 <span style=''>
</span>385 <span style=''>  /**
</span>386 <span style=''>   * Creates a new Observable that only emits the last `n` elements
</span>387 <span style=''>   * emitted by the source.
</span>388 <span style=''>   */
</span>389 <span style=''>  def takeRight(n: Int): Observable[T] =
</span>390 <span style=''>    </span><span style='background: #AEF1AE'>operators.take.right(self, n)</span><span style=''>
</span>391 <span style=''>
</span>392 <span style=''>  /**
</span>393 <span style=''>   * Drops the first ''n'' elements (from the start).
</span>394 <span style=''>   *
</span>395 <span style=''>   *  @param  n  the number of elements to drop
</span>396 <span style=''>   *  @return    a new Observable that drops the first ''n'' elements
</span>397 <span style=''>   *             emitted by the source
</span>398 <span style=''>   */
</span>399 <span style=''>  def drop(n: Int): Observable[T] =
</span>400 <span style=''>    </span><span style='background: #AEF1AE'>operators.drop.byCount(self, n)</span><span style=''>
</span>401 <span style=''>
</span>402 <span style=''>  /**
</span>403 <span style=''>   * Creates a new Observable that drops the events of the source, only
</span>404 <span style=''>   * for the specified `timestamp` window.
</span>405 <span style=''>   *
</span>406 <span style=''>   * @param timespan the window of time during which the new Observable
</span>407 <span style=''>   *                 is must drop the events emitted by the source
</span>408 <span style=''>   */
</span>409 <span style=''>  def dropByTimespan(timespan: FiniteDuration): Observable[T] =
</span>410 <span style=''>    </span><span style='background: #AEF1AE'>operators.drop.byTimespan(self, timespan)</span><span style=''>
</span>411 <span style=''>
</span>412 <span style=''>  /**
</span>413 <span style=''>   * Drops the longest prefix of elements that satisfy the given predicate
</span>414 <span style=''>   * and returns a new Observable that emits the rest.
</span>415 <span style=''>   */
</span>416 <span style=''>  def dropWhile(p: T => Boolean): Observable[T] =
</span>417 <span style=''>    </span><span style='background: #AEF1AE'>operators.drop.byPredicate(self)(p)</span><span style=''>
</span>418 <span style=''>
</span>419 <span style=''>  /**
</span>420 <span style=''>   * Drops the longest prefix of elements that satisfy the given function
</span>421 <span style=''>   * and returns a new Observable that emits the rest. In comparison with
</span>422 <span style=''>   * [[dropWhile]], this version accepts a function that takes an additional
</span>423 <span style=''>   * parameter: the zero-based index of the element.
</span>424 <span style=''>   */
</span>425 <span style=''>  def dropWhileWithIndex(p: (T, Int) => Boolean): Observable[T] =
</span>426 <span style=''>    </span><span style='background: #AEF1AE'>operators.drop.byPredicateWithIndex(self)(p)</span><span style=''>
</span>427 <span style=''>
</span>428 <span style=''>
</span>429 <span style=''>  /**
</span>430 <span style=''>   * Takes longest prefix of elements that satisfy the given predicate
</span>431 <span style=''>   * and returns a new Observable that emits those elements.
</span>432 <span style=''>   */
</span>433 <span style=''>  def takeWhile(p: T => Boolean): Observable[T] =
</span>434 <span style=''>    </span><span style='background: #AEF1AE'>operators.take.byPredicate(self)(p)</span><span style=''>
</span>435 <span style=''>
</span>436 <span style=''>  /**
</span>437 <span style=''>   * Takes longest prefix of elements that satisfy the given predicate
</span>438 <span style=''>   * and returns a new Observable that emits those elements.
</span>439 <span style=''>   */
</span>440 <span style=''>  def takeWhileNotCanceled(c: BooleanCancelable): Observable[T] =
</span>441 <span style=''>    </span><span style='background: #AEF1AE'>operators.take.takeWhileNotCanceled(self, c)</span><span style=''>
</span>442 <span style=''>
</span>443 <span style=''>  /**
</span>444 <span style=''>   * Creates a new Observable that emits the total number of `onNext` events
</span>445 <span style=''>   * that were emitted by the source.
</span>446 <span style=''>   *
</span>447 <span style=''>   * Note that this Observable emits only one item after the source is complete.
</span>448 <span style=''>   * And in case the source emits an error, then only that error will be
</span>449 <span style=''>   * emitted.
</span>450 <span style=''>   */
</span>451 <span style=''>  def count(): Observable[Long] =
</span>452 <span style=''>    </span><span style='background: #AEF1AE'>operators.math.count(self)</span><span style=''>
</span>453 <span style=''>
</span>454 <span style=''>  /**
</span>455 <span style=''>   * Periodically gather items emitted by an Observable into bundles and emit
</span>456 <span style=''>   * these bundles rather than emitting the items one at a time. This version
</span>457 <span style=''>   * of `buffer` is emitting items once the internal buffer has the reached the
</span>458 <span style=''>   * given count.
</span>459 <span style=''>   *
</span>460 <span style=''>   * So in this example, we are creating a new observable that emits sequences of
</span>461 <span style=''>   * exactly 10 elements (or whatever is in the buffer when `onComplete` happens):
</span>462 <span style=''>   * {{{
</span>463 <span style=''>   *   observable.buffer(10)
</span>464 <span style=''>   * }}}
</span>465 <span style=''>   *
</span>466 <span style=''>   * @param count the bundle size
</span>467 <span style=''>   */
</span>468 <span style=''>  def buffer(count: Int): Observable[Seq[T]] =
</span>469 <span style=''>    </span><span style='background: #AEF1AE'>operators.buffer.sized(self, count)</span><span style=''>
</span>470 <span style=''>
</span>471 <span style=''>  /**
</span>472 <span style=''>   * Periodically gather items emitted by an Observable into bundles and emit
</span>473 <span style=''>   * these bundles rather than emitting the items one at a time.
</span>474 <span style=''>   *
</span>475 <span style=''>   * This version of `buffer` emits a new bundle of items periodically,
</span>476 <span style=''>   * every timespan amount of time, containing all items emitted by the
</span>477 <span style=''>   * source Observable since the previous bundle emission.
</span>478 <span style=''>   *
</span>479 <span style=''>   * @param timespan the interval of time at which it should emit the buffered bundle
</span>480 <span style=''>   */
</span>481 <span style=''>  def bufferTimed(timespan: FiniteDuration): Observable[Seq[T]] =
</span>482 <span style=''>    </span><span style='background: #AEF1AE'>operators.buffer.timed(self, timespan)</span><span style=''>
</span>483 <span style=''>
</span>484 <span style=''>  /**
</span>485 <span style=''>   * Periodically gather items emitted by an Observable into bundles and emit
</span>486 <span style=''>   * these bundles rather than emitting the items one at a time.
</span>487 <span style=''>   *
</span>488 <span style=''>   * This version of `buffer` emits a new bundle of items periodically,
</span>489 <span style=''>   * every timespan amount of time, containing all items emitted by the
</span>490 <span style=''>   * source Observable since the previous bundle emission, or when the buffer
</span>491 <span style=''>   * size has reached the given `count`.
</span>492 <span style=''>   *
</span>493 <span style=''>   * @param maxSize is the maximum bundle size
</span>494 <span style=''>   * @param timespan the interval of time at which it should emit the buffered bundle
</span>495 <span style=''>   */
</span>496 <span style=''>  def bufferSizedAndTimed(maxSize: Int, timespan: FiniteDuration): Observable[Seq[T]] =
</span>497 <span style=''>    </span><span style='background: #AEF1AE'>operators.buffer.sizedAndTimed(self, maxSize, timespan)</span><span style=''>
</span>498 <span style=''>
</span>499 <span style=''>  /**
</span>500 <span style=''>   * Emit the most recent items emitted by an Observable within periodic time
</span>501 <span style=''>   * intervals.
</span>502 <span style=''>   *
</span>503 <span style=''>   * Use the sample() method to periodically look at an Observable
</span>504 <span style=''>   * to see what item it has most recently emitted since the previous
</span>505 <span style=''>   * sampling. Note that if the source Observable has emitted no
</span>506 <span style=''>   * items since the last time it was sampled, the Observable that
</span>507 <span style=''>   * results from the sample( ) operator will emit no item for
</span>508 <span style=''>   * that sampling period.
</span>509 <span style=''>   *
</span>510 <span style=''>   * @param delay the timespan at which sampling occurs and note that this is
</span>511 <span style=''>   *              not accurate as it is subject to back-pressure concerns - as in
</span>512 <span style=''>   *              if the delay is 1 second and the processing of an event on `onNext`
</span>513 <span style=''>   *              in the observer takes one second, then the actual sampling delay
</span>514 <span style=''>   *              will be 2 seconds.
</span>515 <span style=''>   */
</span>516 <span style=''>  def sample(delay: FiniteDuration): Observable[T] =
</span>517 <span style=''>    </span><span style='background: #AEF1AE'>sample(delay, delay)</span><span style=''>
</span>518 <span style=''>
</span>519 <span style=''>  /**
</span>520 <span style=''>   * Emit the most recent items emitted by an Observable within periodic time
</span>521 <span style=''>   * intervals.
</span>522 <span style=''>   *
</span>523 <span style=''>   * Use the sample() method to periodically look at an Observable
</span>524 <span style=''>   * to see what item it has most recently emitted since the previous
</span>525 <span style=''>   * sampling. Note that if the source Observable has emitted no
</span>526 <span style=''>   * items since the last time it was sampled, the Observable that
</span>527 <span style=''>   * results from the sample( ) operator will emit no item for
</span>528 <span style=''>   * that sampling period.
</span>529 <span style=''>   *
</span>530 <span style=''>   * @param initialDelay the initial delay after which sampling can happen
</span>531 <span style=''>   *
</span>532 <span style=''>   * @param delay the timespan at which sampling occurs and note that this is
</span>533 <span style=''>   *              not accurate as it is subject to back-pressure concerns - as in
</span>534 <span style=''>   *              if the delay is 1 second and the processing of an event on `onNext`
</span>535 <span style=''>   *              in the observer takes one second, then the actual sampling delay
</span>536 <span style=''>   *              will be 2 seconds.
</span>537 <span style=''>   */
</span>538 <span style=''>  def sample(initialDelay: FiniteDuration, delay: FiniteDuration): Observable[T] =
</span>539 <span style=''>    </span><span style='background: #AEF1AE'>operators.sample.once(self, initialDelay, delay)</span><span style=''>
</span>540 <span style=''>
</span>541 <span style=''>  /**
</span>542 <span style=''>   * Emit the most recent items emitted by an Observable within periodic time
</span>543 <span style=''>   * intervals. If no new value has been emitted since the last time it
</span>544 <span style=''>   * was sampled, the emit the last emitted value anyway.
</span>545 <span style=''>   *
</span>546 <span style=''>   * Also see [[Observable.sample]].
</span>547 <span style=''>   *
</span>548 <span style=''>   * @param delay the timespan at which sampling occurs and note that this is
</span>549 <span style=''>   *              not accurate as it is subject to back-pressure concerns - as in
</span>550 <span style=''>   *              if the delay is 1 second and the processing of an event on `onNext`
</span>551 <span style=''>   *              in the observer takes one second, then the actual sampling delay
</span>552 <span style=''>   *              will be 2 seconds.
</span>553 <span style=''>   */
</span>554 <span style=''>  def sampleRepeated(delay: FiniteDuration): Observable[T] =
</span>555 <span style=''>    </span><span style='background: #AEF1AE'>sampleRepeated(delay, delay)</span><span style=''>
</span>556 <span style=''>
</span>557 <span style=''>  /**
</span>558 <span style=''>   * Emit the most recent items emitted by an Observable within periodic time
</span>559 <span style=''>   * intervals. If no new value has been emitted since the last time it
</span>560 <span style=''>   * was sampled, the emit the last emitted value anyway.
</span>561 <span style=''>   *
</span>562 <span style=''>   * Also see [[Observable!.sample]].
</span>563 <span style=''>   *
</span>564 <span style=''>   * @param initialDelay the initial delay after which sampling can happen
</span>565 <span style=''>   *
</span>566 <span style=''>   * @param delay the timespan at which sampling occurs and note that this is
</span>567 <span style=''>   *              not accurate as it is subject to back-pressure concerns - as in
</span>568 <span style=''>   *              if the delay is 1 second and the processing of an event on `onNext`
</span>569 <span style=''>   *              in the observer takes one second, then the actual sampling delay
</span>570 <span style=''>   *              will be 2 seconds.
</span>571 <span style=''>   */
</span>572 <span style=''>  def sampleRepeated(initialDelay: FiniteDuration, delay: FiniteDuration): Observable[T] =
</span>573 <span style=''>    </span><span style='background: #AEF1AE'>operators.sample.repeated(self, initialDelay, delay)</span><span style=''>
</span>574 <span style=''>
</span>575 <span style=''>  /**
</span>576 <span style=''>   * Only emit an item from an Observable if a particular
</span>577 <span style=''>   * timespan has passed without it emitting another item.
</span>578 <span style=''>   *
</span>579 <span style=''>   * Note: If the source Observable keeps emitting items more frequently
</span>580 <span style=''>   * than the length of the time window then no items will be emitted
</span>581 <span style=''>   * by the resulting Observable.
</span>582 <span style=''>   *
</span>583 <span style=''>   * @param timeout the length of the window of time that must pass after
</span>584 <span style=''>   *                the emission of an item from the source Observable in which
</span>585 <span style=''>   *                that Observable emits no items in order for the item to
</span>586 <span style=''>   *                be emitted by the resulting Observable
</span>587 <span style=''>   */
</span>588 <span style=''>  def debounce(timeout: FiniteDuration): Observable[T] =
</span>589 <span style=''>    </span><span style='background: #AEF1AE'>operators.debounce.apply(self, timeout)</span><span style=''>
</span>590 <span style=''>
</span>591 <span style=''>  /**
</span>592 <span style=''>   * Hold an Observer's subscription request until the given `future` completes,
</span>593 <span style=''>   * before passing it on to the source Observable. If the given `future`
</span>594 <span style=''>   * completes in error, then the subscription is terminated with `onError`.
</span>595 <span style=''>   *
</span>596 <span style=''>   * @param future the `Future` that must complete in order for the
</span>597 <span style=''>   *               subscription to happen.
</span>598 <span style=''>   */
</span>599 <span style=''>  def delaySubscription(future: Future[_]): Observable[T] =
</span>600 <span style=''>    </span><span style='background: #AEF1AE'>operators.delaySubscription.onFuture(self, future)</span><span style=''>
</span>601 <span style=''>
</span>602 <span style=''>  /**
</span>603 <span style=''>   * Hold an Observer's subscription request for a specified
</span>604 <span style=''>   * amount of time before passing it on to the source Observable.
</span>605 <span style=''>   *
</span>606 <span style=''>   * @param timespan is the time to wait before the subscription
</span>607 <span style=''>   *                 is being initiated.
</span>608 <span style=''>   */
</span>609 <span style=''>  def delaySubscription(timespan: FiniteDuration): Observable[T] =
</span>610 <span style=''>    </span><span style='background: #AEF1AE'>operators.delaySubscription.onTimespan(self, timespan)</span><span style=''>
</span>611 <span style=''>
</span>612 <span style=''>  /**
</span>613 <span style=''>   * Applies a binary operator to a start value and all elements of this Observable,
</span>614 <span style=''>   * going left to right and returns a new Observable that emits only one item
</span>615 <span style=''>   * before `onComplete`.
</span>616 <span style=''>   */
</span>617 <span style=''>  def foldLeft[R](initial: R)(op: (R, T) => R): Observable[R] =
</span>618 <span style=''>    </span><span style='background: #AEF1AE'>operators.foldLeft(self, initial)(op)</span><span style=''>
</span>619 <span style=''>
</span>620 <span style=''>  /**
</span>621 <span style=''>   * Applies a binary operator to a start value and all elements of this Observable,
</span>622 <span style=''>   * going left to right and returns a new Observable that emits only one item
</span>623 <span style=''>   * before `onComplete`.
</span>624 <span style=''>   */
</span>625 <span style=''>  def reduce[U >: T](op: (U, U) => U): Observable[U] =
</span>626 <span style=''>    </span><span style='background: #AEF1AE'>operators.reduce(self : Observable[U])(op)</span><span style=''>
</span>627 <span style=''>
</span>628 <span style=''>  /**
</span>629 <span style=''>   * Applies a binary operator to a start value and all elements of this Observable,
</span>630 <span style=''>   * going left to right and returns a new Observable that emits on each step the result
</span>631 <span style=''>   * of the applied function.
</span>632 <span style=''>   *
</span>633 <span style=''>   * Similar to [[foldLeft]], but emits the state on each step. Useful for modeling finite
</span>634 <span style=''>   * state machines.
</span>635 <span style=''>   */
</span>636 <span style=''>  def scan[R](initial: R)(op: (R, T) => R): Observable[R] =
</span>637 <span style=''>    </span><span style='background: #AEF1AE'>operators.scan(self, initial)(op)</span><span style=''>
</span>638 <span style=''>
</span>639 <span style=''>  /**
</span>640 <span style=''>   * Applies a binary operator to a start value and to elements produced
</span>641 <span style=''>   * by the source observable, going from left to right, producing
</span>642 <span style=''>   * and concatenating observables along the way.
</span>643 <span style=''>   *
</span>644 <span style=''>   * It's the combination between [[monifu.reactive.Observable.scan scan]]
</span>645 <span style=''>   * and [[monifu.reactive.Observable.flatten]].
</span>646 <span style=''>   */
</span>647 <span style=''>  def flatScan[R](initial: R)(op: (R, T) => Observable[R]): Observable[R] =
</span>648 <span style=''>    </span><span style='background: #AEF1AE'>operators.flatScan(self, initial)(op)</span><span style=''>
</span>649 <span style=''>
</span>650 <span style=''>  /**
</span>651 <span style=''>   * Applies a binary operator to a start value and to elements produced
</span>652 <span style=''>   * by the source observable, going from left to right, producing
</span>653 <span style=''>   * and concatenating observables along the way.
</span>654 <span style=''>   *
</span>655 <span style=''>   * It's the combination between [[monifu.reactive.Observable.scan scan]]
</span>656 <span style=''>   * and [[monifu.reactive.Observable.flattenDelayError]].
</span>657 <span style=''>   */
</span>658 <span style=''>  def flatScanDelayError[R](initial: R)(op: (R, T) => Observable[R]): Observable[R] =
</span>659 <span style=''>    </span><span style='background: #AEF1AE'>operators.flatScan.delayError(self, initial)(op)</span><span style=''>
</span>660 <span style=''>
</span>661 <span style=''>  /**
</span>662 <span style=''>   * Executes the given callback when the stream has ended,
</span>663 <span style=''>   * but before the complete event is emitted.
</span>664 <span style=''>   *
</span>665 <span style=''>   * @param cb the callback to execute when the subscription is canceled
</span>666 <span style=''>   */
</span>667 <span style=''>  def doOnComplete(cb: => Unit): Observable[T] =
</span>668 <span style=''>    </span><span style='background: #AEF1AE'>operators.doWork.onComplete(self)(cb)</span><span style=''>
</span>669 <span style=''>
</span>670 <span style=''>  /**
</span>671 <span style=''>   * Executes the given callback for each element generated by the source
</span>672 <span style=''>   * Observable, useful for doing side-effects.
</span>673 <span style=''>   *
</span>674 <span style=''>   * @return a new Observable that executes the specified callback for each element
</span>675 <span style=''>   */
</span>676 <span style=''>  def doWork(cb: T => Unit): Observable[T] =
</span>677 <span style=''>    </span><span style='background: #AEF1AE'>operators.doWork.onNext(self)(cb)</span><span style=''>
</span>678 <span style=''>
</span>679 <span style=''>  /**
</span>680 <span style=''>   * Executes the given callback only for the first element generated by the source
</span>681 <span style=''>   * Observable, useful for doing a piece of computation only when the stream started.
</span>682 <span style=''>   *
</span>683 <span style=''>   * @return a new Observable that executes the specified callback only for the first element
</span>684 <span style=''>   */
</span>685 <span style=''>  def doOnStart(cb: T => Unit): Observable[T] =
</span>686 <span style=''>    </span><span style='background: #AEF1AE'>operators.doWork.onStart(self)(cb)</span><span style=''>
</span>687 <span style=''>
</span>688 <span style=''>  /**
</span>689 <span style=''>   * Executes the given callback if the downstream observer
</span>690 <span style=''>   * has canceled the streaming.
</span>691 <span style=''>   */
</span>692 <span style=''>  def doOnCanceled(cb: => Unit): Observable[T] =
</span>693 <span style=''>    </span><span style='background: #AEF1AE'>operators.doWork.onCanceled(self)(cb)</span><span style=''>
</span>694 <span style=''>
</span>695 <span style=''>  /**
</span>696 <span style=''>   * Executes the given callback when the stream is interrupted
</span>697 <span style=''>   * with an error, before the `onError` event is emitted downstream.
</span>698 <span style=''>   *
</span>699 <span style=''>   * NOTE: should protect the code in this callback, because if it
</span>700 <span style=''>   * throws an exception the `onError` event will prefer signaling the
</span>701 <span style=''>   * original exception and otherwise the behavior is undefined.
</span>702 <span style=''>   */
</span>703 <span style=''>  def doOnError(cb: Throwable => Unit): Observable[T] =
</span>704 <span style=''>    </span><span style='background: #AEF1AE'>operators.doWork.onError(self)(cb)</span><span style=''>
</span>705 <span style=''>
</span>706 <span style=''>  /**
</span>707 <span style=''>   * Returns an Observable which only emits the first item for which the predicate holds.
</span>708 <span style=''>   *
</span>709 <span style=''>   * @param p a function that evaluates the items emitted by the source Observable, returning `true` if they pass the filter
</span>710 <span style=''>   * @return an Observable that emits only the first item in the original Observable for which the filter evaluates as `true`
</span>711 <span style=''>   */
</span>712 <span style=''>  def find(p: T => Boolean): Observable[T] =
</span>713 <span style=''>    </span><span style='background: #F0ADAD'>filter(p).head</span><span style=''>
</span>714 <span style=''>
</span>715 <span style=''>  /**
</span>716 <span style=''>   * Returns an Observable which emits a single value, either true, in case the given predicate holds for at least
</span>717 <span style=''>   * one item, or false otherwise.
</span>718 <span style=''>   *
</span>719 <span style=''>   * @param p a function that evaluates the items emitted by the source Observable, returning `true` if they pass the filter
</span>720 <span style=''>   * @return an Observable that emits only true or false in case the given predicate holds or not for at least one item
</span>721 <span style=''>   */
</span>722 <span style=''>  def exists(p: T => Boolean): Observable[Boolean] =
</span>723 <span style=''>    </span><span style='background: #F0ADAD'>find(p).foldLeft(false)((_, _) => true)</span><span style=''>
</span>724 <span style=''>
</span>725 <span style=''>  /**
</span>726 <span style=''>   * Returns an Observable that emits true if the source Observable
</span>727 <span style=''>   * is empty, otherwise false.
</span>728 <span style=''>   */
</span>729 <span style=''>  def isEmpty: Observable[Boolean] =
</span>730 <span style=''>    </span><span style='background: #AEF1AE'>operators.misc.isEmpty(self)</span><span style=''>
</span>731 <span style=''>
</span>732 <span style=''>  /**
</span>733 <span style=''>   * Returns an Observable that emits false if the source Observable
</span>734 <span style=''>   * is empty, otherwise true.
</span>735 <span style=''>   */
</span>736 <span style=''>  def nonEmpty: Observable[Boolean] =
</span>737 <span style=''>    </span><span style='background: #AEF1AE'>operators.misc.isEmpty(self).map(isEmpty => !isEmpty)</span><span style=''>
</span>738 <span style=''>
</span>739 <span style=''>  /**
</span>740 <span style=''>   * Returns an Observable that emits a single boolean, either true, in case the given predicate holds for all the items
</span>741 <span style=''>   * emitted by the source, or false in case at least one item is not verifying the given predicate.
</span>742 <span style=''>   *
</span>743 <span style=''>   * @param p a function that evaluates the items emitted by the source Observable, returning `true` if they pass the filter
</span>744 <span style=''>   * @return an Observable that emits only true or false in case the given predicate holds or not for all the items
</span>745 <span style=''>   */
</span>746 <span style=''>  def forAll(p: T => Boolean): Observable[Boolean] =
</span>747 <span style=''>    </span><span style='background: #F0ADAD'>exists(e => !p(e)).map(r => !r)</span><span style=''>
</span>748 <span style=''>
</span>749 <span style=''>  /**
</span>750 <span style=''>   * Returns an Observable that doesn't emit anything,
</span>751 <span style=''>   * but that completes when the source Observable completes.
</span>752 <span style=''>   */
</span>753 <span style=''>  def complete: Observable[Nothing] =
</span>754 <span style=''>    </span><span style='background: #AEF1AE'>operators.misc.complete(this)</span><span style=''>
</span>755 <span style=''>
</span>756 <span style=''>  /**
</span>757 <span style=''>   * Returns an Observable that emits a single Throwable,
</span>758 <span style=''>   * in case an error was thrown by the source Observable,
</span>759 <span style=''>   * otherwise it isn't going to emit anything.
</span>760 <span style=''>   */
</span>761 <span style=''>  def error: Observable[Throwable] =
</span>762 <span style=''>    </span><span style='background: #AEF1AE'>operators.misc.error(this)</span><span style=''>
</span>763 <span style=''>
</span>764 <span style=''>  /**
</span>765 <span style=''>   * Emits the given exception instead of `onComplete`.
</span>766 <span style=''>   * @param error the exception to emit onComplete
</span>767 <span style=''>   * @return a new Observable that emits an exception onComplete
</span>768 <span style=''>   */
</span>769 <span style=''>  def endWithError(error: Throwable): Observable[T] =
</span>770 <span style=''>    </span><span style='background: #AEF1AE'>operators.misc.endWithError(this)(error)</span><span style=''>
</span>771 <span style=''>
</span>772 <span style=''>  /**
</span>773 <span style=''>   * Creates a new Observable that emits the given element
</span>774 <span style=''>   * and then it also emits the events of the source (prepend operation).
</span>775 <span style=''>   */
</span>776 <span style=''>  def +:[U >: T](elem: U): Observable[U] =
</span>777 <span style=''>    </span><span style='background: #F0ADAD'>Observable.unit(elem) ++ this</span><span style=''>
</span>778 <span style=''>
</span>779 <span style=''>  /**
</span>780 <span style=''>   * Creates a new Observable that emits the given elements
</span>781 <span style=''>   * and then it also emits the events of the source (prepend operation).
</span>782 <span style=''>   */
</span>783 <span style=''>  def startWith[U >: T](elems: U*): Observable[U] =
</span>784 <span style=''>    </span><span style='background: #F0ADAD'>Observable.fromIterable(elems) ++ this</span><span style=''>
</span>785 <span style=''>
</span>786 <span style=''>  /**
</span>787 <span style=''>   * Creates a new Observable that emits the events of the source
</span>788 <span style=''>   * and then it also emits the given element (appended to the stream).
</span>789 <span style=''>   */
</span>790 <span style=''>  def :+[U >: T](elem: U): Observable[U] =
</span>791 <span style=''>    </span><span style='background: #F0ADAD'>this ++ Observable.unit(elem)</span><span style=''>
</span>792 <span style=''>
</span>793 <span style=''>  /**
</span>794 <span style=''>   * Creates a new Observable that emits the events of the source
</span>795 <span style=''>   * and then it also emits the given elements (appended to the stream).
</span>796 <span style=''>   */
</span>797 <span style=''>  def endWith[U >: T](elems: U*): Observable[U] =
</span>798 <span style=''>    </span><span style='background: #F0ADAD'>this ++ Observable.fromIterable(elems)</span><span style=''>
</span>799 <span style=''>
</span>800 <span style=''>  /**
</span>801 <span style=''>   * Concatenates the source Observable with the other Observable, as specified.
</span>802 <span style=''>   */
</span>803 <span style=''>  def ++[U >: T](other: => Observable[U]): Observable[U] =
</span>804 <span style=''>    </span><span style='background: #AEF1AE'>Observable.concat(this, other)</span><span style=''>
</span>805 <span style=''>
</span>806 <span style=''>  /**
</span>807 <span style=''>   * Only emits the first element emitted by the source observable, after which it's completed immediately.
</span>808 <span style=''>   */
</span>809 <span style=''>  def head: Observable[T] = </span><span style='background: #AEF1AE'>take(1)</span><span style=''>
</span>810 <span style=''>
</span>811 <span style=''>  /**
</span>812 <span style=''>   * Drops the first element of the source observable, emitting the rest.
</span>813 <span style=''>   */
</span>814 <span style=''>  def tail: Observable[T] = </span><span style='background: #F0ADAD'>drop(1)</span><span style=''>
</span>815 <span style=''>
</span>816 <span style=''>  /**
</span>817 <span style=''>   * Only emits the last element emitted by the source observable, after which it's completed immediately.
</span>818 <span style=''>   */
</span>819 <span style=''>  def last: Observable[T] =
</span>820 <span style=''>    </span><span style='background: #F0ADAD'>takeRight(1)</span><span style=''>
</span>821 <span style=''>
</span>822 <span style=''>  /**
</span>823 <span style=''>   * Emits the first element emitted by the source, or otherwise if the source is completed without
</span>824 <span style=''>   * emitting anything, then the `default` is emitted.
</span>825 <span style=''>   */
</span>826 <span style=''>  def headOrElse[B >: T](default: => B): Observable[B] =
</span>827 <span style=''>    </span><span style='background: #F0ADAD'>head.foldLeft(Option.empty[B])((_, elem) => Some(elem)) map {
</span>828 <span style=''></span><span style='background: #F0ADAD'>      case Some(elem) => elem
</span>829 <span style=''></span><span style='background: #F0ADAD'>      case None => default
</span>830 <span style=''></span><span style='background: #F0ADAD'>    }</span><span style=''>
</span>831 <span style=''>
</span>832 <span style=''>  /**
</span>833 <span style=''>   * Emits the first element emitted by the source, or otherwise if the source is completed without
</span>834 <span style=''>   * emitting anything, then the `default` is emitted.
</span>835 <span style=''>   *
</span>836 <span style=''>   * Alias for `headOrElse`.
</span>837 <span style=''>   */
</span>838 <span style=''>  def firstOrElse[U >: T](default: => U): Observable[U] =
</span>839 <span style=''>    </span><span style='background: #F0ADAD'>headOrElse(default)</span><span style=''>
</span>840 <span style=''>
</span>841 <span style=''>  /**
</span>842 <span style=''>   * Creates a new Observable from this Observable and another given Observable,
</span>843 <span style=''>   * by emitting elements combined in pairs. If one of the Observable emits fewer
</span>844 <span style=''>   * events than the other, then the rest of the unpaired events are ignored.
</span>845 <span style=''>   */
</span>846 <span style=''>  def zip[U](other: Observable[U]): Observable[(T, U)] =
</span>847 <span style=''>    </span><span style='background: #AEF1AE'>operators.zip(self, other)</span><span style=''>
</span>848 <span style=''>
</span>849 <span style=''>  /**
</span>850 <span style=''>   * Creates a new Observable from this Observable and another given Observable.
</span>851 <span style=''>   *
</span>852 <span style=''>   * This operator behaves in a similar way to [[zip]], but while `zip` emits items
</span>853 <span style=''>   * only when all of the zipped source Observables have emitted a previously unzipped item,
</span>854 <span style=''>   * `combine` emits an item whenever any of the source Observables emits
</span>855 <span style=''>   * an item (so long as each of the source Observables has emitted at least one item).
</span>856 <span style=''>   */
</span>857 <span style=''>  def combineLatest[U](other: Observable[U]): Observable[(T, U)] =
</span>858 <span style=''>    </span><span style='background: #AEF1AE'>operators.combineLatest(self, other, delayErrors = false)</span><span style=''>
</span>859 <span style=''>
</span>860 <span style=''>  /**
</span>861 <span style=''>   * Creates a new Observable from this Observable and another given Observable.
</span>862 <span style=''>   *
</span>863 <span style=''>   * It's like [[Observable.combineLatest]], except that the created observable is reserving onError
</span>864 <span style=''>   * notifications until all of the combined Observables complete and only then passing it along
</span>865 <span style=''>   * to the observers.
</span>866 <span style=''>   */
</span>867 <span style=''>  def combineLatestDelayError[U](other: Observable[U]): Observable[(T, U)] =
</span>868 <span style=''>    </span><span style='background: #AEF1AE'>operators.combineLatest(self, other, delayErrors = true)</span><span style=''>
</span>869 <span style=''>
</span>870 <span style=''>  /**
</span>871 <span style=''>   * Takes the elements of the source Observable and emits the maximum value,
</span>872 <span style=''>   * after the source has completed.
</span>873 <span style=''>   */
</span>874 <span style=''>  def max[U >: T](implicit ev: Ordering[U]): Observable[U] =
</span>875 <span style=''>    </span><span style='background: #AEF1AE'>operators.math.max(this : Observable[U])</span><span style=''>
</span>876 <span style=''>
</span>877 <span style=''>  /**
</span>878 <span style=''>   * Takes the elements of the source Observable and emits the element that has
</span>879 <span style=''>   * the maximum key value, where the key is generated by the given function `f`.
</span>880 <span style=''>   */
</span>881 <span style=''>  def maxBy[U](f: T => U)(implicit ev: Ordering[U]): Observable[T] =
</span>882 <span style=''>    </span><span style='background: #AEF1AE'>operators.math.maxBy(this)(f)(ev)</span><span style=''>
</span>883 <span style=''>
</span>884 <span style=''>  /**
</span>885 <span style=''>   * Takes the elements of the source Observable and emits the minimum value,
</span>886 <span style=''>   * after the source has completed.
</span>887 <span style=''>   */
</span>888 <span style=''>  def min[U >: T](implicit ev: Ordering[U]): Observable[U] =
</span>889 <span style=''>    </span><span style='background: #AEF1AE'>operators.math.min(this : Observable[U])</span><span style=''>
</span>890 <span style=''>
</span>891 <span style=''>  /**
</span>892 <span style=''>   * Takes the elements of the source Observable and emits the element that has
</span>893 <span style=''>   * the minimum key value, where the key is generated by the given function `f`.
</span>894 <span style=''>   */
</span>895 <span style=''>  def minBy[U](f: T => U)(implicit ev: Ordering[U]): Observable[T] =
</span>896 <span style=''>    </span><span style='background: #AEF1AE'>operators.math.minBy(this)(f)</span><span style=''>
</span>897 <span style=''>
</span>898 <span style=''>  /**
</span>899 <span style=''>   * Given a source that emits numeric values, the `sum` operator
</span>900 <span style=''>   * sums up all values and at onComplete it emits the total.
</span>901 <span style=''>   */
</span>902 <span style=''>  def sum[U >: T](implicit ev: Numeric[U]): Observable[U] =
</span>903 <span style=''>    </span><span style='background: #AEF1AE'>operators.math.sum(this : Observable[U])</span><span style=''>
</span>904 <span style=''>
</span>905 <span style=''>  /**
</span>906 <span style=''>   * Suppress the duplicate elements emitted by the source Observable.
</span>907 <span style=''>   *
</span>908 <span style=''>   * WARNING: this requires unbounded buffering.
</span>909 <span style=''>   */
</span>910 <span style=''>  def distinct: Observable[T] =
</span>911 <span style=''>    </span><span style='background: #AEF1AE'>operators.distinct.distinct(this)</span><span style=''>
</span>912 <span style=''>
</span>913 <span style=''>  /**
</span>914 <span style=''>   * Given a function that returns a key for each element emitted by
</span>915 <span style=''>   * the source Observable, suppress duplicates items.
</span>916 <span style=''>   *
</span>917 <span style=''>   * WARNING: this requires unbounded buffering.
</span>918 <span style=''>   */
</span>919 <span style=''>  def distinct[U](fn: T => U): Observable[T] =
</span>920 <span style=''>    </span><span style='background: #AEF1AE'>operators.distinct.distinctBy(this)(fn)</span><span style=''>
</span>921 <span style=''>
</span>922 <span style=''>  /**
</span>923 <span style=''>   * Suppress duplicate consecutive items emitted by the source Observable
</span>924 <span style=''>   */
</span>925 <span style=''>  def distinctUntilChanged: Observable[T] =
</span>926 <span style=''>    </span><span style='background: #AEF1AE'>operators.distinct.untilChanged(this)</span><span style=''>
</span>927 <span style=''>
</span>928 <span style=''>  /**
</span>929 <span style=''>   * Suppress duplicate consecutive items emitted by the source Observable
</span>930 <span style=''>   */
</span>931 <span style=''>  def distinctUntilChanged[U](fn: T => U): Observable[T] =
</span>932 <span style=''>    </span><span style='background: #AEF1AE'>operators.distinct.untilChangedBy(this)(fn)</span><span style=''>
</span>933 <span style=''>
</span>934 <span style=''>  /**
</span>935 <span style=''>   * Returns a new Observable that uses the specified
</span>936 <span style=''>   * `Scheduler` for initiating the subscription.
</span>937 <span style=''>   */
</span>938 <span style=''>  def subscribeOn(s: Scheduler): Observable[T] = {
</span>939 <span style=''>    </span><span style='background: #F0ADAD'>Observable.create(o => s.execute(unsafeSubscribe(o)))</span><span style=''>
</span>940 <span style=''>  }
</span>941 <span style=''>
</span>942 <span style=''>  /**
</span>943 <span style=''>   * Converts the source Observable that emits `T` into an Observable
</span>944 <span style=''>   * that emits `Notification[T]`.
</span>945 <span style=''>   *
</span>946 <span style=''>   * NOTE: `onComplete` is still emitted after an `onNext(OnComplete)` notification
</span>947 <span style=''>   * however an `onError(ex)` notification is emitted as an `onNext(OnError(ex))`
</span>948 <span style=''>   * followed by an `onComplete`.
</span>949 <span style=''>   */
</span>950 <span style=''>  def materialize: Observable[Notification[T]] =
</span>951 <span style=''>    </span><span style='background: #AEF1AE'>operators.materialize(self)</span><span style=''>
</span>952 <span style=''>
</span>953 <span style=''>  /**
</span>954 <span style=''>   * Utility that can be used for debugging purposes.
</span>955 <span style=''>   */
</span>956 <span style=''>  def dump(prefix: String, out: PrintStream = System.out): Observable[T] =
</span>957 <span style=''>    </span><span style='background: #AEF1AE'>operators.debug.dump(self, prefix, out)</span><span style=''>
</span>958 <span style=''>
</span>959 <span style=''>  /**
</span>960 <span style=''>   * Repeats the items emitted by this Observable continuously. It caches the generated items until `onComplete`
</span>961 <span style=''>   * and repeats them ad infinitum. On error it terminates.
</span>962 <span style=''>   */
</span>963 <span style=''>  def repeat: Observable[T] =
</span>964 <span style=''>    </span><span style='background: #AEF1AE'>operators.repeat(self)</span><span style=''>
</span>965 <span style=''>
</span>966 <span style=''>  /**
</span>967 <span style=''>   * Converts this observable into a multicast observable, useful for turning a cold observable into
</span>968 <span style=''>   * a hot one (i.e. whose source is shared by all observers).
</span>969 <span style=''>   */
</span>970 <span style=''>  def multicast[R](subject: Subject[T, R])(implicit s: Scheduler): ConnectableObservable[R] =
</span>971 <span style=''>    </span><span style='background: #F0ADAD'>ConnectableObservable(this, subject)</span><span style=''>
</span>972 <span style=''>
</span>973 <span style=''>  /**
</span>974 <span style=''>   * Forces a buffered asynchronous boundary.
</span>975 <span style=''>   *
</span>976 <span style=''>   * Internally it wraps the observer implementation given to `subscribeFn` into a
</span>977 <span style=''>   * [[monifu.reactive.observers.BufferedSubscriber BufferedSubscriber]].
</span>978 <span style=''>   *
</span>979 <span style=''>   * Normally Monifu's implementation guarantees that events are not emitted concurrently,
</span>980 <span style=''>   * and that the publisher MUST NOT emit the next event without acknowledgement from the consumer
</span>981 <span style=''>   * that it may proceed, however for badly behaved publishers, this wrapper provides
</span>982 <span style=''>   * the guarantee that the downstream [[monifu.reactive.Observer Observer]] given in `subscribe` will not receive
</span>983 <span style=''>   * concurrent events.
</span>984 <span style=''>   *
</span>985 <span style=''>   * WARNING: if the buffer created by this operator is unbounded, it can blow up the process if the data source
</span>986 <span style=''>   * is pushing events faster than what the observer can consume, as it introduces an asynchronous
</span>987 <span style=''>   * boundary that eliminates the back-pressure requirements of the data source. Unbounded is the default
</span>988 <span style=''>   * [[monifu.reactive.BufferPolicy policy]], see [[monifu.reactive.BufferPolicy BufferPolicy]]
</span>989 <span style=''>   * for options.
</span>990 <span style=''>   */
</span>991 <span style=''>  def asyncBoundary[U >: T](policy: BufferPolicy[U] = defaultPolicy): Observable[U] =
</span>992 <span style=''>    </span><span style='background: #F0ADAD'>Observable.create { subscriber =>
</span>993 <span style=''></span><span style='background: #F0ADAD'>      implicit val s = subscriber.scheduler
</span>994 <span style=''></span><span style='background: #F0ADAD'>      unsafeSubscribe(BufferedSubscriber(subscriber.observer, policy))
</span>995 <span style=''></span><span style='background: #F0ADAD'>    }</span><span style=''>
</span>996 <span style=''>
</span>997 <span style=''>  /**
</span>998 <span style=''>   * While the destination observer is busy, drop the incoming events.
</span>999 <span style=''>   */
</span>1000 <span style=''>  def whileBusyDropEvents: Observable[T] =
</span>1001 <span style=''>    </span><span style='background: #AEF1AE'>operators.whileBusy.dropEvents(self)</span><span style=''>
</span>1002 <span style=''>
</span>1003 <span style=''>  /**
</span>1004 <span style=''>   * While the destination observer is busy, drop the incoming events.
</span>1005 <span style=''>   * When the downstream recovers, we can signal a special event
</span>1006 <span style=''>   * meant to inform the downstream observer how many events
</span>1007 <span style=''>   * where dropped.
</span>1008 <span style=''>   *
</span>1009 <span style=''>   * @param onOverflow is a function used to build a message that will be
</span>1010 <span style=''>   *                   the first event sent after the observer recovers,
</span>1011 <span style=''>   *                   a function receiving as argument the number of dropped
</span>1012 <span style=''>   *                   messages and thus can be used to inform the downstream
</span>1013 <span style=''>   *                   how many messages it missed.
</span>1014 <span style=''>   */
</span>1015 <span style=''>  def whileBusyDropEventsThenSignalOverflow[U >: T](onOverflow: Long => U): Observable[U] =
</span>1016 <span style=''>    </span><span style='background: #AEF1AE'>operators.whileBusy.dropEventsThenSignalOverflow(self, onOverflow)</span><span style=''>
</span>1017 <span style=''>
</span>1018 <span style=''>  /**
</span>1019 <span style=''>   * While the destination observer is busy, buffers events then send
</span>1020 <span style=''>   * whatever was buffered in one big batch.
</span>1021 <span style=''>   */
</span>1022 <span style=''>  def whileBusyBufferEvents(bufferSize: Int): Observable[Seq[T]] =
</span>1023 <span style=''>    </span><span style='background: #AEF1AE'>operators.whileBusy.bufferEvents(self, bufferSize)</span><span style=''>
</span>1024 <span style=''>
</span>1025 <span style=''>  /**
</span>1026 <span style=''>   * Converts this observable into a multicast observable, useful for turning a cold observable into
</span>1027 <span style=''>   * a hot one (i.e. whose source is shared by all observers). The underlying subject used is a
</span>1028 <span style=''>   * [[monifu.reactive.subjects.PublishSubject PublishSubject]].
</span>1029 <span style=''>   */
</span>1030 <span style=''>  def publish()(implicit s: Scheduler): ConnectableObservable[T] =
</span>1031 <span style=''>    </span><span style='background: #F0ADAD'>multicast(PublishSubject())</span><span style=''>
</span>1032 <span style=''>
</span>1033 <span style=''>  /**
</span>1034 <span style=''>   * Converts this observable into a multicast observable, useful for turning a cold observable into
</span>1035 <span style=''>   * a hot one (i.e. whose source is shared by all observers). The underlying subject used is a
</span>1036 <span style=''>   * [[monifu.reactive.subjects.BehaviorSubject BehaviorSubject]].
</span>1037 <span style=''>   */
</span>1038 <span style=''>  def behavior[U >: T](initialValue: U)(implicit s: Scheduler): ConnectableObservable[U] =
</span>1039 <span style=''>    </span><span style='background: #F0ADAD'>multicast(BehaviorSubject(initialValue))</span><span style=''>
</span>1040 <span style=''>
</span>1041 <span style=''>  /**
</span>1042 <span style=''>   * Converts this observable into a multicast observable, useful for turning a cold observable into
</span>1043 <span style=''>   * a hot one (i.e. whose source is shared by all observers). The underlying subject used is a
</span>1044 <span style=''>   * [[monifu.reactive.subjects.ReplaySubject ReplaySubject]].
</span>1045 <span style=''>   */
</span>1046 <span style=''>  def replay()(implicit s: Scheduler): ConnectableObservable[T] =
</span>1047 <span style=''>    </span><span style='background: #F0ADAD'>multicast(ReplaySubject())</span><span style=''>
</span>1048 <span style=''>
</span>1049 <span style=''>  /**
</span>1050 <span style=''>   * Converts this observable into a multicast observable, useful for turning a cold observable into
</span>1051 <span style=''>   * a hot one (i.e. whose source is shared by all observers). The underlying subject used is a
</span>1052 <span style=''>   * [[monifu.reactive.subjects.AsyncSubject AsyncSubject]].
</span>1053 <span style=''>   */
</span>1054 <span style=''>  def publishLast()(implicit s: Scheduler): ConnectableObservable[T] =
</span>1055 <span style=''>    </span><span style='background: #F0ADAD'>multicast(AsyncSubject())</span><span style=''>
</span>1056 <span style=''>
</span>1057 <span style=''>  /**
</span>1058 <span style=''>   * Returns an Observable that mirrors the behavior of the source,
</span>1059 <span style=''>   * unless the source is terminated with an `onError`, in which
</span>1060 <span style=''>   * case the streaming of events continues with the specified 
</span>1061 <span style=''>   * backup sequence generated by the given partial function.
</span>1062 <span style=''>   *
</span>1063 <span style=''>   * The created Observable mirrors the behavior of the source
</span>1064 <span style=''>   * in case the source does not end with an error or if the
</span>1065 <span style=''>   * thrown `Throwable` is not matched.
</span>1066 <span style=''>   *
</span>1067 <span style=''>   * NOTE that compared with `onErrorResumeNext` from Rx.NET,
</span>1068 <span style=''>   * the streaming is not resumed in case the source is
</span>1069 <span style=''>   * terminated normally with an `onComplete`.
</span>1070 <span style=''>   *
</span>1071 <span style=''>   * @param pf - a partial function that matches errors with a
</span>1072 <span style=''>   *           backup throwable that is subscribed when the source
</span>1073 <span style=''>   *           throws an error.
</span>1074 <span style=''>   */
</span>1075 <span style=''>  def onErrorRecoverWith[U >: T](pf: PartialFunction[Throwable, Observable[U]]): Observable[U] =
</span>1076 <span style=''>    </span><span style='background: #AEF1AE'>operators.onError.recoverWith(self, pf)</span><span style=''>
</span>1077 <span style=''>
</span>1078 <span style=''>  /**
</span>1079 <span style=''>   * Returns an Observable that mirrors the behavior of the source,
</span>1080 <span style=''>   * unless the source is terminated with an `onError`, in which
</span>1081 <span style=''>   * case the streaming of events continues with the specified
</span>1082 <span style=''>   * backup sequence.
</span>1083 <span style=''>   *
</span>1084 <span style=''>   * The created Observable mirrors the behavior of the source
</span>1085 <span style=''>   * in case the source does not end with an error.
</span>1086 <span style=''>   *
</span>1087 <span style=''>   * NOTE that compared with `onErrorResumeNext` from Rx.NET,
</span>1088 <span style=''>   * the streaming is not resumed in case the source is
</span>1089 <span style=''>   * terminated normally with an `onComplete`.
</span>1090 <span style=''>   *
</span>1091 <span style=''>   * @param that - a backup sequence that's being subscribed
</span>1092 <span style=''>   *             in case the source terminates with an error.
</span>1093 <span style=''>   */
</span>1094 <span style=''>  def onErrorFallbackTo[U >: T](that: => Observable[U]): Observable[U] =
</span>1095 <span style=''>    </span><span style='background: #AEF1AE'>operators.onError.fallbackTo(self, that)</span><span style=''>
</span>1096 <span style=''>
</span>1097 <span style=''>  /**
</span>1098 <span style=''>   * Returns an Observable that mirrors the behavior of the source,
</span>1099 <span style=''>   * unless the source is terminated with an `onError`, in which case
</span>1100 <span style=''>   * it tries subscribing to the source again in the hope that
</span>1101 <span style=''>   * it will complete without an error.
</span>1102 <span style=''>   *
</span>1103 <span style=''>   * NOTE: The number of retries is unlimited, so something like
</span>1104 <span style=''>   * `Observable.error(new RuntimeException).onErrorRetryUnlimited` will loop
</span>1105 <span style=''>   * forever.
</span>1106 <span style=''>   */
</span>1107 <span style=''>  def onErrorRetryUnlimited: Observable[T] =
</span>1108 <span style=''>    </span><span style='background: #AEF1AE'>operators.onError.retryUnlimited(self)</span><span style=''>
</span>1109 <span style=''>
</span>1110 <span style=''>  /**
</span>1111 <span style=''>   * Returns an Observable that mirrors the behavior of the source,
</span>1112 <span style=''>   * unless the source is terminated with an `onError`, in which case
</span>1113 <span style=''>   * it tries subscribing to the source again in the hope that
</span>1114 <span style=''>   * it will complete without an error.
</span>1115 <span style=''>   *
</span>1116 <span style=''>   * The number of retries is limited by the specified `maxRetries`
</span>1117 <span style=''>   * parameter, so for an Observable that always ends in error the
</span>1118 <span style=''>   * total number of subscriptions that will eventually happen is
</span>1119 <span style=''>   * `maxRetries + 1`.
</span>1120 <span style=''>   */
</span>1121 <span style=''>  def onErrorRetry(maxRetries: Long): Observable[T] =
</span>1122 <span style=''>    </span><span style='background: #AEF1AE'>operators.onError.retryCounted(self, maxRetries)</span><span style=''>
</span>1123 <span style=''>
</span>1124 <span style=''>  /**
</span>1125 <span style=''>   * Returns an Observable that mirrors the behavior of the source,
</span>1126 <span style=''>   * unless the source is terminated with an `onError`, in which case
</span>1127 <span style=''>   * it tries subscribing to the source again in the hope that
</span>1128 <span style=''>   * it will complete without an error.
</span>1129 <span style=''>   *
</span>1130 <span style=''>   * The given predicate establishes if the subscription should be
</span>1131 <span style=''>   * retried or not.
</span>1132 <span style=''>   */
</span>1133 <span style=''>  def onErrorRetryIf(p: Throwable => Boolean): Observable[T] =
</span>1134 <span style=''>    </span><span style='background: #AEF1AE'>operators.onError.retryIf(self, p)</span><span style=''>
</span>1135 <span style=''>
</span>1136 <span style=''>  /**
</span>1137 <span style=''>   * Returns an Observable that mirrors the source Observable but
</span>1138 <span style=''>   * applies a timeout policy for each emitted item. If the next item
</span>1139 <span style=''>   * isn't emitted within the specified timeout duration starting from
</span>1140 <span style=''>   * its predecessor, the resulting Observable terminates and notifies
</span>1141 <span style=''>   * observers of a TimeoutException.
</span>1142 <span style=''>   *
</span>1143 <span style=''>   * @param timeout maximum duration between emitted items before
</span>1144 <span style=''>   *                a timeout occurs
</span>1145 <span style=''>   */
</span>1146 <span style=''>  def timeout(timeout: FiniteDuration): Observable[T] =
</span>1147 <span style=''>    </span><span style='background: #AEF1AE'>operators.timeout.emitError(self, timeout)</span><span style=''>
</span>1148 <span style=''>
</span>1149 <span style=''>  /**
</span>1150 <span style=''>   * Returns an Observable that mirrors the source Observable but
</span>1151 <span style=''>   * applies a timeout policy for each emitted item. If the next item
</span>1152 <span style=''>   * isn't emitted within the specified timeout duration starting from
</span>1153 <span style=''>   * its predecessor, the resulting Observable begins instead to
</span>1154 <span style=''>   * mirror a backup Observable.
</span>1155 <span style=''>   *
</span>1156 <span style=''>   * @param timeout maximum duration between emitted items before
</span>1157 <span style=''>   *                a timeout occurs
</span>1158 <span style=''>   * @param backup is the backup observable to subscribe to
</span>1159 <span style=''>   *               in case of a timeout
</span>1160 <span style=''>   */
</span>1161 <span style=''>  def timeout[U >: T](timeout: FiniteDuration, backup: Observable[U]): Observable[U] =
</span>1162 <span style=''>    </span><span style='background: #F0ADAD'>operators.timeout.switchToBackup(self, timeout, backup)</span><span style=''>
</span>1163 <span style=''>
</span>1164 <span style=''>  /**
</span>1165 <span style=''>   * Given a function that transforms an `Observable[T]` into an `Observable[U]`,
</span>1166 <span style=''>   * it transforms the source observable into an `Observable[U]`.
</span>1167 <span style=''>   */
</span>1168 <span style=''>  def lift[U](f: Observable[T] => Observable[U]): Observable[U] =
</span>1169 <span style=''>    </span><span style='background: #F0ADAD'>f(self)</span><span style=''>
</span>1170 <span style=''>
</span>1171 <span style=''>  /**
</span>1172 <span style=''>   * Returns the first generated result as a Future and then cancels
</span>1173 <span style=''>   * the subscription.
</span>1174 <span style=''>   */
</span>1175 <span style=''>  def asFuture(implicit s: Scheduler): Future[Option[T]] = {
</span>1176 <span style=''>    val promise = </span><span style='background: #AEF1AE'>Promise[Option[T]]()</span><span style=''>
</span>1177 <span style=''>
</span>1178 <span style=''>    </span><span style='background: #AEF1AE'>head.unsafeSubscribe(new Observer[T] {
</span>1179 <span style=''></span><span style='background: #AEF1AE'>      def onNext(elem: T) = {
</span>1180 <span style=''></span><span style='background: #AEF1AE'>        promise.trySuccess(Some(elem))
</span>1181 <span style=''></span><span style='background: #AEF1AE'>        Cancel
</span>1182 <span style=''></span><span style='background: #AEF1AE'>      }
</span>1183 <span style=''></span><span style='background: #AEF1AE'>
</span>1184 <span style=''></span><span style='background: #AEF1AE'>      def onComplete() = {
</span>1185 <span style=''></span><span style='background: #AEF1AE'>        promise.trySuccess(None)
</span>1186 <span style=''></span><span style='background: #AEF1AE'>      }
</span>1187 <span style=''></span><span style='background: #AEF1AE'>
</span>1188 <span style=''></span><span style='background: #AEF1AE'>      def onError(ex: Throwable) = {
</span>1189 <span style=''></span><span style='background: #AEF1AE'>        promise.tryFailure(ex)
</span>1190 <span style=''></span><span style='background: #AEF1AE'>      }
</span>1191 <span style=''></span><span style='background: #AEF1AE'>    })</span><span style=''>
</span>1192 <span style=''>
</span>1193 <span style=''>    </span><span style='background: #AEF1AE'>promise.future</span><span style=''>
</span>1194 <span style=''>  }
</span>1195 <span style=''>
</span>1196 <span style=''>  /**
</span>1197 <span style=''>   * Subscribes to the source `Observable` and foreach element emitted by the source
</span>1198 <span style=''>   * it executes the given callback.
</span>1199 <span style=''>   */
</span>1200 <span style=''>  def foreach(cb: T => Unit)(implicit s: Scheduler): Unit =
</span>1201 <span style=''>    </span><span style='background: #F0ADAD'>unsafeSubscribe(new Observer[T] {
</span>1202 <span style=''></span><span style='background: #F0ADAD'>      def onNext(elem: T) =
</span>1203 <span style=''></span><span style='background: #F0ADAD'>        try { cb(elem); Continue } catch {
</span>1204 <span style=''></span><span style='background: #F0ADAD'>          case NonFatal(ex) =>
</span>1205 <span style=''></span><span style='background: #F0ADAD'>            onError(ex)
</span>1206 <span style=''></span><span style='background: #F0ADAD'>            Cancel
</span>1207 <span style=''></span><span style='background: #F0ADAD'>        }
</span>1208 <span style=''></span><span style='background: #F0ADAD'>
</span>1209 <span style=''></span><span style='background: #F0ADAD'>      def onComplete() = ()
</span>1210 <span style=''></span><span style='background: #F0ADAD'>      def onError(ex: Throwable) = {
</span>1211 <span style=''></span><span style='background: #F0ADAD'>        s.reportFailure(ex)
</span>1212 <span style=''></span><span style='background: #F0ADAD'>      }
</span>1213 <span style=''></span><span style='background: #F0ADAD'>    })</span><span style=''>
</span>1214 <span style=''>}
</span>1215 <span style=''>
</span>1216 <span style=''>object Observable {
</span>1217 <span style=''>  /**
</span>1218 <span style=''>   * Observable constructor for creating an [[Observable]] from the specified function.
</span>1219 <span style=''>   *
</span>1220 <span style=''>   * <img src="https://raw.githubusercontent.com/wiki/monifu/monifu/assets/rx-operators/create.png" />
</span>1221 <span style=''>   *
</span>1222 <span style=''>   * Example: {{{
</span>1223 <span style=''>   *   import monifu.reactive._
</span>1224 <span style=''>   *   import monifu.reactive.Ack.Continue
</span>1225 <span style=''>   *   import concurrent.ExecutionContext
</span>1226 <span style=''>   *
</span>1227 <span style=''>   *   def emit[T](elem: T, nrOfTimes: Int)(implicit s: Scheduler): Observable[T] =
</span>1228 <span style=''>   *     Observable.create { observer =>
</span>1229 <span style=''>   *       def loop(times: Int): Unit =
</span>1230 <span style=''>   *         ec.execute(new Runnable {
</span>1231 <span style=''>   *           def run() = {
</span>1232 <span style=''>   *             if (times > 0)
</span>1233 <span style=''>   *               observer.onNext(elem).onSuccess {
</span>1234 <span style=''>   *                 case Continue => loop(times - 1)
</span>1235 <span style=''>   *               }
</span>1236 <span style=''>   *             else
</span>1237 <span style=''>   *               observer.onComplete()
</span>1238 <span style=''>   *           }
</span>1239 <span style=''>   *         })
</span>1240 <span style=''>   *
</span>1241 <span style=''>   *       loop(nrOfTimes)
</span>1242 <span style=''>   *     }
</span>1243 <span style=''>   *
</span>1244 <span style=''>   *   // usage sample
</span>1245 <span style=''>   *   import concurrent.ExecutionContext.Implicits.global
</span>1246 <span style=''>
</span>1247 <span style=''>   *   emit(elem=30, nrOfTimes=3).dump("Emit").subscribe()
</span>1248 <span style=''>   *   //=> 0: Emit-->30
</span>1249 <span style=''>   *   //=> 1: Emit-->30
</span>1250 <span style=''>   *   //=> 2: Emit-->30
</span>1251 <span style=''>   *   //=> 3: Emit completed
</span>1252 <span style=''>   * }}}
</span>1253 <span style=''>   */
</span>1254 <span style=''>  def create[T](f: Subscriber[T] => Unit): Observable[T] = {
</span>1255 <span style=''>    </span><span style='background: #AEF1AE'>new</span><span style=''> Observable[T] {
</span>1256 <span style=''>      def subscribeFn(subscriber: Subscriber[T]): Unit =
</span>1257 <span style=''>        try </span><span style='background: #AEF1AE'>f(subscriber)</span><span style=''> catch {
</span>1258 <span style=''>          case NonFatal(ex) =>
</span>1259 <span style=''>            </span><span style='background: #F0ADAD'>subscriber.observer.onError(ex)</span><span style=''>
</span>1260 <span style=''>        }
</span>1261 <span style=''>    }
</span>1262 <span style=''>  }
</span>1263 <span style=''>
</span>1264 <span style=''>  /**
</span>1265 <span style=''>   * Creates an observable that doesn't emit anything, but immediately calls `onComplete`
</span>1266 <span style=''>   * instead.
</span>1267 <span style=''>   *
</span>1268 <span style=''>   * <img src="https://raw.githubusercontent.com/wiki/monifu/monifu/assets/rx-operators/empty.png" />
</span>1269 <span style=''>   */
</span>1270 <span style=''>  def empty: Observable[Nothing] =
</span>1271 <span style=''>    </span><span style='background: #AEF1AE'>builders.unit.empty</span><span style=''>
</span>1272 <span style=''>
</span>1273 <span style=''>  /**
</span>1274 <span style=''>   * Creates an Observable that only emits the given ''a''
</span>1275 <span style=''>   *
</span>1276 <span style=''>   * <img src="https://raw.githubusercontent.com/wiki/monifu/monifu/assets/rx-operators/unit.png" />
</span>1277 <span style=''>   */
</span>1278 <span style=''>  def unit[A](elem: A): Observable[A] =
</span>1279 <span style=''>    </span><span style='background: #AEF1AE'>builders.unit.one(elem)</span><span style=''>
</span>1280 <span style=''>
</span>1281 <span style=''>  /**
</span>1282 <span style=''>   * Creates an Observable that emits an error.
</span>1283 <span style=''>   *
</span>1284 <span style=''>   * <img src="https://raw.githubusercontent.com/wiki/monifu/monifu/assets/rx-operators/error.png" />
</span>1285 <span style=''>   */
</span>1286 <span style=''>  def error(ex: Throwable): Observable[Nothing] =
</span>1287 <span style=''>    </span><span style='background: #AEF1AE'>builders.unit.error(ex)</span><span style=''>
</span>1288 <span style=''>
</span>1289 <span style=''>  /**
</span>1290 <span style=''>   * Creates an Observable that doesn't emit anything and that never completes.
</span>1291 <span style=''>   *
</span>1292 <span style=''>   * <img src="https://raw.githubusercontent.com/wiki/monifu/monifu/assets/rx-operators/never.png"" />
</span>1293 <span style=''>   */
</span>1294 <span style=''>  def never: Observable[Nothing] =
</span>1295 <span style=''>    </span><span style='background: #AEF1AE'>builders.unit.never</span><span style=''>
</span>1296 <span style=''>
</span>1297 <span style=''>  /**
</span>1298 <span style=''>   * Creates an Observable that emits auto-incremented natural numbers (longs) spaced by
</span>1299 <span style=''>   * a given time interval. Starts from 0 with no delay, after which it emits incremented
</span>1300 <span style=''>   * numbers spaced by the `period` of time. The given `period` of time acts as a fixed delay
</span>1301 <span style=''>   * between subsequent events.
</span>1302 <span style=''>   *
</span>1303 <span style=''>   * <img src="https://raw.githubusercontent.com/wiki/monifu/monifu/assets/rx-operators/interval.png"" />
</span>1304 <span style=''>   *
</span>1305 <span style=''>   * @param delay the delay between two subsequent events
</span>1306 <span style=''>   */
</span>1307 <span style=''>  def intervalWithFixedDelay(delay: FiniteDuration): Observable[Long] =
</span>1308 <span style=''>    </span><span style='background: #AEF1AE'>builders.interval.withFixedDelay(delay)</span><span style=''>
</span>1309 <span style=''>
</span>1310 <span style=''>  /**
</span>1311 <span style=''>   * Creates an Observable that emits auto-incremented natural numbers (longs) spaced by
</span>1312 <span style=''>   * a given time interval. Starts from 0 with no delay, after which it emits incremented
</span>1313 <span style=''>   * numbers spaced by the `period` of time. The given `period` of time acts as a fixed delay
</span>1314 <span style=''>   * between subsequent events.
</span>1315 <span style=''>   *
</span>1316 <span style=''>   * <img src="https://raw.githubusercontent.com/wiki/monifu/monifu/assets/rx-operators/interval.png"" />
</span>1317 <span style=''>   *
</span>1318 <span style=''>   * @param delay the delay between two subsequent events
</span>1319 <span style=''>   */
</span>1320 <span style=''>  def interval(delay: FiniteDuration): Observable[Long] =
</span>1321 <span style=''>    </span><span style='background: #F0ADAD'>intervalWithFixedDelay(delay)</span><span style=''>
</span>1322 <span style=''>
</span>1323 <span style=''>  /**
</span>1324 <span style=''>   * Creates an Observable that emits auto-incremented natural numbers (longs) at a fixed rate,
</span>1325 <span style=''>   * as given by the specified `period`. The time it takes to process an `onNext` event gets
</span>1326 <span style=''>   * subtracted from the specified `period` and thus the created observable tries to emit events
</span>1327 <span style=''>   * spaced by the given time interval, regardless of how long the processing of `onNext` takes.
</span>1328 <span style=''>   *
</span>1329 <span style=''>   * For example, an invocation like this:
</span>1330 <span style=''>   * {{{
</span>1331 <span style=''>   *   Observable.intervalAtFixedRate(1.second)
</span>1332 <span style=''>   * }}}
</span>1333 <span style=''>   *
</span>1334 <span style=''>   * Is roughly equivalent to this:
</span>1335 <span style=''>   * {{{
</span>1336 <span style=''>   *   import monifu.concurrent.extensions._
</span>1337 <span style=''>   *
</span>1338 <span style=''>   *   Observable.range(0, Long.MaxValue)
</span>1339 <span style=''>   *     .flatMap(x => Future(x).withMinDuration(1.second))
</span>1340 <span style=''>   * }}}
</span>1341 <span style=''>   *
</span>1342 <span style=''>   * @param period is the period of time the observable waits between 2 subsequent `onNext` events
</span>1343 <span style=''>   */
</span>1344 <span style=''>  def intervalAtFixedRate(period: FiniteDuration): Observable[Long] =
</span>1345 <span style=''>    </span><span style='background: #AEF1AE'>builders.interval.atFixedRate(period)</span><span style=''>
</span>1346 <span style=''>
</span>1347 <span style=''>  /**
</span>1348 <span style=''>   * Creates an Observable that continuously emits the given ''item'' repeatedly.
</span>1349 <span style=''>   */
</span>1350 <span style=''>  def repeat[T](elems: T*): Observable[T] =
</span>1351 <span style=''>    </span><span style='background: #AEF1AE'>builders.repeat(elems : _*)</span><span style=''>
</span>1352 <span style=''>
</span>1353 <span style=''>  /**
</span>1354 <span style=''>   * Creates an Observable that emits items in the given range.
</span>1355 <span style=''>   *
</span>1356 <span style=''>   * <img src="https://raw.githubusercontent.com/wiki/monifu/monifu/assets/rx-operators/range.png" />
</span>1357 <span style=''>   *
</span>1358 <span style=''>   * @param from the range start
</span>1359 <span style=''>   * @param until the range end
</span>1360 <span style=''>   * @param step increment step, either positive or negative
</span>1361 <span style=''>   */
</span>1362 <span style=''>  def range(from: Long, until: Long, step: Long = 1L): Observable[Long] =
</span>1363 <span style=''>    </span><span style='background: #AEF1AE'>builders.range(from, until, step)</span><span style=''>
</span>1364 <span style=''>
</span>1365 <span style=''>  /**
</span>1366 <span style=''>   * Creates an Observable that emits the given elements.
</span>1367 <span style=''>   *
</span>1368 <span style=''>   * Usage sample: {{{
</span>1369 <span style=''>   *   val obs = Observable(1, 2, 3, 4)
</span>1370 <span style=''>   *
</span>1371 <span style=''>   *   obs.dump("MyObservable").subscribe()
</span>1372 <span style=''>   *   //=> 0: MyObservable-->1
</span>1373 <span style=''>   *   //=> 1: MyObservable-->2
</span>1374 <span style=''>   *   //=> 2: MyObservable-->3
</span>1375 <span style=''>   *   //=> 3: MyObservable-->4
</span>1376 <span style=''>   *   //=> 4: MyObservable completed
</span>1377 <span style=''>   * }}}
</span>1378 <span style=''>   */
</span>1379 <span style=''>  def apply[T](elems: T*): Observable[T] = {
</span>1380 <span style=''>    </span><span style='background: #F0ADAD'>fromIterable(elems)</span><span style=''>
</span>1381 <span style=''>  }
</span>1382 <span style=''>
</span>1383 <span style=''>  /**
</span>1384 <span style=''>   * Converts a Future to an Observable.
</span>1385 <span style=''>   *
</span>1386 <span style=''>   * <img src="https://raw.githubusercontent.com/wiki/monifu/monifu/assets/rx-operators/fromIterable.png" />
</span>1387 <span style=''>   */
</span>1388 <span style=''>  def fromFuture[T](future: Future[T]): Observable[T] =
</span>1389 <span style=''>    </span><span style='background: #AEF1AE'>builders.from.future(future)</span><span style=''>
</span>1390 <span style=''>
</span>1391 <span style=''>  /**
</span>1392 <span style=''>   * Creates an Observable that emits the elements of the given ''iterable''.
</span>1393 <span style=''>   *
</span>1394 <span style=''>   * <img src="https://raw.githubusercontent.com/wiki/monifu/monifu/assets/rx-operators/fromIterable.png" />
</span>1395 <span style=''>   */
</span>1396 <span style=''>  def fromIterable[T](iterable: Iterable[T]): Observable[T] =
</span>1397 <span style=''>    </span><span style='background: #AEF1AE'>builders.from.iterable(iterable)</span><span style=''>
</span>1398 <span style=''>
</span>1399 <span style=''>  /**
</span>1400 <span style=''>   * Creates an Observable that emits the given elements exactly.
</span>1401 <span style=''>   *
</span>1402 <span style=''>   * <img src="https://raw.githubusercontent.com/wiki/monifu/monifu/assets/rx-operators/fromIterable.png" />
</span>1403 <span style=''>   */
</span>1404 <span style=''>  def from[T](elems: T*): Observable[T] =
</span>1405 <span style=''>    </span><span style='background: #AEF1AE'>builders.from.iterable(elems)</span><span style=''>
</span>1406 <span style=''>
</span>1407 <span style=''>  /**
</span>1408 <span style=''>   * Create an Observable that emits a single item after a given delay.
</span>1409 <span style=''>   */
</span>1410 <span style=''>  def unitDelayed[T](delay: FiniteDuration, unit: T): Observable[T] =
</span>1411 <span style=''>    </span><span style='background: #AEF1AE'>builders.unit.oneDelayed(delay, unit)</span><span style=''>
</span>1412 <span style=''>
</span>1413 <span style=''>  /**
</span>1414 <span style=''>   * Create an Observable that repeatedly emits the given `item`, until
</span>1415 <span style=''>   * the underlying Observer cancels.
</span>1416 <span style=''>   */
</span>1417 <span style=''>  def timerRepeated[T](initialDelay: FiniteDuration, period: FiniteDuration, unit: T): Observable[T] =
</span>1418 <span style=''>    </span><span style='background: #AEF1AE'>builders.timer.repeated(initialDelay, period, unit)</span><span style=''>
</span>1419 <span style=''>
</span>1420 <span style=''>  /**
</span>1421 <span style=''>   * Concatenates the given list of ''observables'' into a single observable.
</span>1422 <span style=''>   */
</span>1423 <span style=''>  def flatten[T](sources: Observable[T]*): Observable[T] =
</span>1424 <span style=''>    </span><span style='background: #F0ADAD'>Observable.fromIterable(sources).concat</span><span style=''>
</span>1425 <span style=''>
</span>1426 <span style=''>  /**
</span>1427 <span style=''>   * Concatenates the given list of ''observables'' into a single observable.
</span>1428 <span style=''>   * Delays errors until the end.
</span>1429 <span style=''>   */
</span>1430 <span style=''>  def flattenDelayError[T](sources: Observable[T]*): Observable[T] =
</span>1431 <span style=''>    </span><span style='background: #F0ADAD'>Observable.fromIterable(sources).concatDelayError</span><span style=''>
</span>1432 <span style=''>
</span>1433 <span style=''>  /**
</span>1434 <span style=''>   * Merges the given list of ''observables'' into a single observable.
</span>1435 <span style=''>   */
</span>1436 <span style=''>  def merge[T](sources: Observable[T]*): Observable[T] =
</span>1437 <span style=''>    </span><span style='background: #AEF1AE'>Observable.fromIterable(sources).merge()</span><span style=''>
</span>1438 <span style=''>
</span>1439 <span style=''>  /**
</span>1440 <span style=''>   * Merges the given list of ''observables'' into a single observable.
</span>1441 <span style=''>   * Delays errors until the end.
</span>1442 <span style=''>   */
</span>1443 <span style=''>  def mergeDelayError[T](sources: Observable[T]*): Observable[T] =
</span>1444 <span style=''>    </span><span style='background: #F0ADAD'>Observable.fromIterable(sources).mergeDelayError()</span><span style=''>
</span>1445 <span style=''>
</span>1446 <span style=''>
</span>1447 <span style=''>  /**
</span>1448 <span style=''>   * Concatenates the given list of ''observables'' into a single observable.
</span>1449 <span style=''>   */
</span>1450 <span style=''>  def concat[T](sources: Observable[T]*): Observable[T] =
</span>1451 <span style=''>    </span><span style='background: #AEF1AE'>Observable.fromIterable(sources).concat</span><span style=''>
</span>1452 <span style=''>
</span>1453 <span style=''>  /**
</span>1454 <span style=''>   * Concatenates the given list of ''observables'' into a single observable.
</span>1455 <span style=''>   * Delays errors until the end.
</span>1456 <span style=''>   */
</span>1457 <span style=''>  def concatDelayError[T](sources: Observable[T]*): Observable[T] =
</span>1458 <span style=''>    </span><span style='background: #F0ADAD'>Observable.fromIterable(sources).concatDelayError</span><span style=''>
</span>1459 <span style=''>
</span>1460 <span style=''>  /**
</span>1461 <span style=''>   * Creates a new Observable from two observables,
</span>1462 <span style=''>   * by emitting elements combined in pairs. If one of the Observable emits fewer
</span>1463 <span style=''>   * events than the other, then the rest of the unpaired events are ignored.
</span>1464 <span style=''>   */
</span>1465 <span style=''>  def zip[T1, T2](obs1: Observable[T1], obs2: Observable[T2]): Observable[(T1,T2)] =
</span>1466 <span style=''>    </span><span style='background: #AEF1AE'>obs1.zip(obs2)</span><span style=''>
</span>1467 <span style=''>
</span>1468 <span style=''>  /**
</span>1469 <span style=''>   * Creates a new Observable from three observables,
</span>1470 <span style=''>   * by emitting elements combined in tuples of 3 elements. If one of the Observable emits fewer
</span>1471 <span style=''>   * events than the others, then the rest of the unpaired events are ignored.
</span>1472 <span style=''>   */
</span>1473 <span style=''>  def zip[T1, T2, T3](obs1: Observable[T1], obs2: Observable[T2], obs3: Observable[T3]): Observable[(T1, T2, T3)] =
</span>1474 <span style=''>    </span><span style='background: #F0ADAD'>obs1.zip(obs2).zip(obs3).map { case ((t1, t2), t3) => (t1, t2, t3) }</span><span style=''>
</span>1475 <span style=''>
</span>1476 <span style=''>  /**
</span>1477 <span style=''>   * Creates a new Observable from three observables,
</span>1478 <span style=''>   * by emitting elements combined in tuples of 4 elements. If one of the Observable emits fewer
</span>1479 <span style=''>   * events than the others, then the rest of the unpaired events are ignored.
</span>1480 <span style=''>   */
</span>1481 <span style=''>  def zip[T1, T2, T3, T4](obs1: Observable[T1], obs2: Observable[T2], obs3: Observable[T3], obs4: Observable[T4]): Observable[(T1, T2, T3, T4)] =
</span>1482 <span style=''>    </span><span style='background: #F0ADAD'>obs1.zip(obs2).zip(obs3).zip(obs4).map { case (((t1, t2), t3), t4) => (t1, t2, t3, t4) }</span><span style=''>
</span>1483 <span style=''>
</span>1484 <span style=''>  /**
</span>1485 <span style=''>   * Creates a combined observable from 2 source observables.
</span>1486 <span style=''>   *
</span>1487 <span style=''>   * This operator behaves in a similar way to [[zip]], but while `zip` emits items
</span>1488 <span style=''>   * only when all of the zipped source Observables have emitted a previously unzipped item,
</span>1489 <span style=''>   * `combine` emits an item whenever any of the source Observables emits
</span>1490 <span style=''>   * an item (so long as each of the source Observables has emitted at least one item).
</span>1491 <span style=''>   */
</span>1492 <span style=''>  def combineLatest[T1, T2](first: Observable[T1], second: Observable[T2]): Observable[(T1,T2)] = {
</span>1493 <span style=''>    </span><span style='background: #AEF1AE'>first.combineLatest(second)</span><span style=''>
</span>1494 <span style=''>  }
</span>1495 <span style=''>
</span>1496 <span style=''>  /**
</span>1497 <span style=''>   * Creates a combined observable from 3 source observables.
</span>1498 <span style=''>   *
</span>1499 <span style=''>   * This operator behaves in a similar way to [[zip]], but while `zip` emits items
</span>1500 <span style=''>   * only when all of the zipped source Observables have emitted a previously unzipped item,
</span>1501 <span style=''>   * `combine` emits an item whenever any of the source Observables emits
</span>1502 <span style=''>   * an item (so long as each of the source Observables has emitted at least one item).
</span>1503 <span style=''>   */
</span>1504 <span style=''>  def combineLatest[T1, T2, T3]
</span>1505 <span style=''>      (first: Observable[T1], second: Observable[T2], third: Observable[T3]): Observable[(T1,T2,T3)] = {
</span>1506 <span style=''>
</span>1507 <span style=''>    </span><span style='background: #F0ADAD'>first.combineLatest(second).combineLatest(third)
</span>1508 <span style=''></span><span style='background: #F0ADAD'>      .map { case ((t1, t2), t3) => (t1, t2, t3) }</span><span style=''>
</span>1509 <span style=''>  }
</span>1510 <span style=''>
</span>1511 <span style=''>  /**
</span>1512 <span style=''>   * Creates a combined observable from 4 source observables.
</span>1513 <span style=''>   *
</span>1514 <span style=''>   * This operator behaves in a similar way to [[zip]], but while `zip` emits items
</span>1515 <span style=''>   * only when all of the zipped source Observables have emitted a previously unzipped item,
</span>1516 <span style=''>   * `combine` emits an item whenever any of the source Observables emits
</span>1517 <span style=''>   * an item (so long as each of the source Observables has emitted at least one item).
</span>1518 <span style=''>   */
</span>1519 <span style=''>  def combineLatest[T1, T2, T3, T4]
</span>1520 <span style=''>      (first: Observable[T1], second: Observable[T2],
</span>1521 <span style=''>       third: Observable[T3], fourth: Observable[T4]): Observable[(T1, T2, T3, T4)] = {
</span>1522 <span style=''>
</span>1523 <span style=''>    </span><span style='background: #F0ADAD'>first.combineLatest(second).combineLatest(third).combineLatest(fourth)
</span>1524 <span style=''></span><span style='background: #F0ADAD'>      .map { case (((t1, t2), t3), t4) => (t1, t2, t3, t4) }</span><span style=''>
</span>1525 <span style=''>  }
</span>1526 <span style=''>
</span>1527 <span style=''>  /**
</span>1528 <span style=''>   * Given a list of source Observables, emits all of the items from the first of
</span>1529 <span style=''>   * these Observables to emit an item and cancel the rest.
</span>1530 <span style=''>   */
</span>1531 <span style=''>  def amb[T](source: Observable[T]*): Observable[T] =
</span>1532 <span style=''>    </span><span style='background: #F0ADAD'>builders.amb(source : _*)</span><span style=''>
</span>1533 <span style=''>
</span>1534 <span style=''>  /**
</span>1535 <span style=''>   * Implicit conversion from Future to Observable.
</span>1536 <span style=''>   */
</span>1537 <span style=''>  implicit def FutureIsObservable[T](future: Future[T]): Observable[T] =
</span>1538 <span style=''>    </span><span style='background: #F0ADAD'>Observable.fromFuture(future)</span><span style=''>
</span>1539 <span style=''>
</span>1540 <span style=''>  /**
</span>1541 <span style=''>   * Implicit conversion from Observable to Publisher.
</span>1542 <span style=''>   */
</span>1543 <span style=''>  implicit def ObservableIsPublisher[T](source: Observable[T])(implicit s: Scheduler): Publisher[T] =
</span>1544 <span style=''>    </span><span style='background: #AEF1AE'>source.publisher</span><span style=''>
</span>1545 <span style=''>}
</span></pre>
          </div>
          <div class="tab-pane" id="statementlist">
            <table cellspacing="0" cellpadding="0" class="table statementlist">
      <tr>
        <th>Line</th>
        <th>Stmt Id</th>
        <th>Pos</th>
        <th>Tree</th>
        <th>Symbol</th>
        <th>Code</th>
      </tr><tr>
        <td>
          53
        </td>
        <td>
          2504
        </td>
        <td>
          2045
          -
          2064
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.concurrent.cancelables.BooleanCancelable.apply
        </td>
        <td style="background: #AEF1AE">
          monifu.concurrent.cancelables.BooleanCancelable.apply()
        </td>
      </tr><tr>
        <td>
          54
        </td>
        <td>
          2505
        </td>
        <td>
          2069
          -
          2144
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          monifu.reactive.Observable.unsafeSubscribe
        </td>
        <td style="background: #AEF1AE">
          Observable.this.takeWhileNotCanceled(cancelable).unsafeSubscribe(monifu.reactive.observers.SafeObserver.apply[T](observer)(s))(s)
        </td>
      </tr><tr>
        <td>
          64
        </td>
        <td>
          2506
        </td>
        <td>
          2383
          -
          2544
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          monifu.reactive.Observable.subscribe
        </td>
        <td style="background: #AEF1AE">
          Observable.this.subscribe({
  final class $anon extends AnyRef with monifu.reactive.Observer[T] {
    def &lt;init&gt;(): &lt;$anon: monifu.reactive.Observer[T]&gt; = {
      $anon.super.&lt;init&gt;();
      ()
    };
    def onNext(elem: T): scala.concurrent.Future[monifu.reactive.Ack] = nextFn.apply(elem);
    def onComplete(): Unit = completedFn.apply();
    def onError(ex: Throwable): Unit = errorFn.apply(ex)
  };
  new $anon()
})(s)
        </td>
      </tr><tr>
        <td>
          75
        </td>
        <td>
          2507
        </td>
        <td>
          2733
          -
          2769
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          monifu.reactive.Observable.subscribe
        </td>
        <td style="background: #F0ADAD">
          Observable.this.subscribe(nextFn, errorFn, (() =&gt; ()))(s)
        </td>
      </tr><tr>
        <td>
          81
        </td>
        <td>
          2508
        </td>
        <td>
          2895
          -
          2922
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          monifu.reactive.Observable.subscribe
        </td>
        <td style="background: #AEF1AE">
          Observable.this.subscribe(((elem: T) =&gt; monifu.reactive.Ack.Continue))(s)
        </td>
      </tr><tr>
        <td>
          87
        </td>
        <td>
          2509
        </td>
        <td>
          3079
          -
          3139
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          monifu.reactive.Observable.subscribe
        </td>
        <td style="background: #AEF1AE">
          Observable.this.subscribe(nextFn, ((error: Throwable) =&gt; s.reportFailure(error)), (() =&gt; ()))(s)
        </td>
      </tr><tr>
        <td>
          102
        </td>
        <td>
          2511
        </td>
        <td>
          3823
          -
          3859
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.subscribeFn
        </td>
        <td style="background: #AEF1AE">
          Observable.this.subscribeFn(Subscriber.apply[T](observer, s))
        </td>
      </tr><tr>
        <td>
          102
        </td>
        <td>
          2510
        </td>
        <td>
          3835
          -
          3858
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Subscriber.apply
        </td>
        <td style="background: #AEF1AE">
          Subscriber.apply[T](observer, s)
        </td>
      </tr><tr>
        <td>
          115
        </td>
        <td>
          2512
        </td>
        <td>
          4403
          -
          4426
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.subscribeFn
        </td>
        <td style="background: #AEF1AE">
          Observable.this.subscribeFn(subscriber)
        </td>
      </tr><tr>
        <td>
          122
        </td>
        <td>
          2516
        </td>
        <td>
          4578
          -
          4581
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.$anon.&lt;init&gt;
        </td>
        <td style="background: #AEF1AE">
          new $anon()
        </td>
      </tr><tr>
        <td>
          124
        </td>
        <td>
          2514
        </td>
        <td>
          4680
          -
          4734
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Subscriber.apply
        </td>
        <td style="background: #AEF1AE">
          Subscriber.apply[_$1](monifu.reactive.observers.SafeObserver.apply[_$1](Observer.from[_$1](subscriber)(s))(s), s)
        </td>
      </tr><tr>
        <td>
          124
        </td>
        <td>
          2513
        </td>
        <td>
          4691
          -
          4730
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          monifu.reactive.observers.SafeObserver.apply
        </td>
        <td style="background: #AEF1AE">
          monifu.reactive.observers.SafeObserver.apply[_$1](Observer.from[_$1](subscriber)(s))(s)
        </td>
      </tr><tr>
        <td>
          124
        </td>
        <td>
          2515
        </td>
        <td>
          4668
          -
          4735
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.subscribeFn
        </td>
        <td style="background: #AEF1AE">
          Observable.this.subscribeFn(Subscriber.apply[_$1](monifu.reactive.observers.SafeObserver.apply[_$1](Observer.from[_$1](subscriber)(s))(s), s))
        </td>
      </tr><tr>
        <td>
          136
        </td>
        <td>
          2517
        </td>
        <td>
          5120
          -
          5142
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.map.apply
        </td>
        <td style="background: #AEF1AE">
          operators.map.apply[T, U](Observable.this)(f)
        </td>
      </tr><tr>
        <td>
          148
        </td>
        <td>
          2518
        </td>
        <td>
          5585
          -
          5610
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.filter.apply
        </td>
        <td style="background: #AEF1AE">
          operators.filter.apply[T](Observable.this)(p)
        </td>
      </tr><tr>
        <td>
          160
        </td>
        <td>
          2519
        </td>
        <td>
          6088
          -
          6115
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.collect.apply
        </td>
        <td style="background: #AEF1AE">
          operators.collect.apply[T, U](Observable.this)(pf)
        </td>
      </tr><tr>
        <td>
          173
        </td>
        <td>
          2520
        </td>
        <td>
          6826
          -
          6826
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Predef.$conforms
        </td>
        <td style="background: #AEF1AE">
          scala.this.Predef.$conforms[monifu.reactive.Observable[U]]
        </td>
      </tr><tr>
        <td>
          173
        </td>
        <td>
          2521
        </td>
        <td>
          6819
          -
          6833
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          monifu.reactive.Observable.flatten
        </td>
        <td style="background: #AEF1AE">
          Observable.this.map[monifu.reactive.Observable[U]](f).flatten[U](scala.this.Predef.$conforms[monifu.reactive.Observable[U]])
        </td>
      </tr><tr>
        <td>
          188
        </td>
        <td>
          2523
        </td>
        <td>
          7611
          -
          7634
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          monifu.reactive.Observable.concatDelayError
        </td>
        <td style="background: #AEF1AE">
          Observable.this.map[monifu.reactive.Observable[U]](f).concatDelayError[U](scala.this.Predef.$conforms[monifu.reactive.Observable[U]])
        </td>
      </tr><tr>
        <td>
          188
        </td>
        <td>
          2522
        </td>
        <td>
          7618
          -
          7618
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Predef.$conforms
        </td>
        <td style="background: #AEF1AE">
          scala.this.Predef.$conforms[monifu.reactive.Observable[U]]
        </td>
      </tr><tr>
        <td>
          201
        </td>
        <td>
          2525
        </td>
        <td>
          8340
          -
          8353
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          monifu.reactive.Observable.concat
        </td>
        <td style="background: #F0ADAD">
          Observable.this.map[monifu.reactive.Observable[U]](f).concat[U](scala.this.Predef.$conforms[monifu.reactive.Observable[U]])
        </td>
      </tr><tr>
        <td>
          201
        </td>
        <td>
          2524
        </td>
        <td>
          8347
          -
          8347
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Predef.$conforms
        </td>
        <td style="background: #F0ADAD">
          scala.this.Predef.$conforms[monifu.reactive.Observable[U]]
        </td>
      </tr><tr>
        <td>
          218
        </td>
        <td>
          2526
        </td>
        <td>
          9296
          -
          9296
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Predef.$conforms
        </td>
        <td style="background: #F0ADAD">
          scala.this.Predef.$conforms[monifu.reactive.Observable[U]]
        </td>
      </tr><tr>
        <td>
          218
        </td>
        <td>
          2527
        </td>
        <td>
          9289
          -
          9312
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          monifu.reactive.Observable.concatDelayError
        </td>
        <td style="background: #F0ADAD">
          Observable.this.map[monifu.reactive.Observable[U]](f).concatDelayError[U](scala.this.Predef.$conforms[monifu.reactive.Observable[U]])
        </td>
      </tr><tr>
        <td>
          231
        </td>
        <td>
          2529
        </td>
        <td>
          10005
          -
          10005
        </td>
        <td>
          TypeApply
        </td>
        <td>
          monifu.reactive.Observable.merge$default$1
        </td>
        <td style="background: #AEF1AE">
          qual$1.merge$default$1[Nothing]
        </td>
      </tr><tr>
        <td>
          231
        </td>
        <td>
          2528
        </td>
        <td>
          9998
          -
          10004
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.map
        </td>
        <td style="background: #AEF1AE">
          Observable.this.map[monifu.reactive.Observable[U]](f)
        </td>
      </tr><tr>
        <td>
          231
        </td>
        <td>
          2531
        </td>
        <td>
          9998
          -
          10012
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.merge
        </td>
        <td style="background: #AEF1AE">
          qual$1.merge[U](x$4)(scala.this.Predef.$conforms[monifu.reactive.Observable[U]])
        </td>
      </tr><tr>
        <td>
          231
        </td>
        <td>
          2530
        </td>
        <td>
          10010
          -
          10010
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Predef.$conforms
        </td>
        <td style="background: #AEF1AE">
          scala.this.Predef.$conforms[monifu.reactive.Observable[U]]
        </td>
      </tr><tr>
        <td>
          248
        </td>
        <td>
          2532
        </td>
        <td>
          10927
          -
          10933
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.map
        </td>
        <td style="background: #AEF1AE">
          Observable.this.map[monifu.reactive.Observable[U]](f)
        </td>
      </tr><tr>
        <td>
          248
        </td>
        <td>
          2535
        </td>
        <td>
          10927
          -
          10951
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.mergeDelayError
        </td>
        <td style="background: #AEF1AE">
          qual$2.mergeDelayError[U](x$5)(scala.this.Predef.$conforms[monifu.reactive.Observable[U]])
        </td>
      </tr><tr>
        <td>
          248
        </td>
        <td>
          2534
        </td>
        <td>
          10949
          -
          10949
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Predef.$conforms
        </td>
        <td style="background: #AEF1AE">
          scala.this.Predef.$conforms[monifu.reactive.Observable[U]]
        </td>
      </tr><tr>
        <td>
          248
        </td>
        <td>
          2533
        </td>
        <td>
          10934
          -
          10934
        </td>
        <td>
          TypeApply
        </td>
        <td>
          monifu.reactive.Observable.mergeDelayError$default$1
        </td>
        <td style="background: #AEF1AE">
          qual$2.mergeDelayError$default$1[Nothing]
        </td>
      </tr><tr>
        <td>
          260
        </td>
        <td>
          2536
        </td>
        <td>
          11357
          -
          11363
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          monifu.reactive.Observable.concat
        </td>
        <td style="background: #AEF1AE">
          Observable.this.concat[U](ev)
        </td>
      </tr><tr>
        <td>
          272
        </td>
        <td>
          2537
        </td>
        <td>
          11818
          -
          11834
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          monifu.reactive.Observable.concatDelayError
        </td>
        <td style="background: #F0ADAD">
          Observable.this.concatDelayError[U](ev)
        </td>
      </tr><tr>
        <td>
          291
        </td>
        <td>
          2538
        </td>
        <td>
          12816
          -
          12867
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          monifu.reactive.operators.flatten.concat
        </td>
        <td style="background: #AEF1AE">
          operators.flatten.concat[T, U](Observable.this, false)(ev)
        </td>
      </tr><tr>
        <td>
          305
        </td>
        <td>
          2539
        </td>
        <td>
          13452
          -
          13502
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          monifu.reactive.operators.flatten.concat
        </td>
        <td style="background: #AEF1AE">
          operators.flatten.concat[T, U](Observable.this, true)(ev)
        </td>
      </tr><tr>
        <td>
          329
        </td>
        <td>
          2540
        </td>
        <td>
          14787
          -
          14851
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          monifu.reactive.operators.flatten.merge
        </td>
        <td style="background: #AEF1AE">
          operators.flatten.merge[T, U](Observable.this, bufferPolicy, false)(ev)
        </td>
      </tr><tr>
        <td>
          349
        </td>
        <td>
          2541
        </td>
        <td>
          15883
          -
          15946
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          monifu.reactive.operators.flatten.merge
        </td>
        <td style="background: #AEF1AE">
          operators.flatten.merge[T, U](Observable.this, bufferPolicy, true)(ev)
        </td>
      </tr><tr>
        <td>
          356
        </td>
        <td>
          2542
        </td>
        <td>
          16188
          -
          16215
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.amb
        </td>
        <td style="background: #F0ADAD">
          Observable.amb[U](Observable.this, other)
        </td>
      </tr><tr>
        <td>
          364
        </td>
        <td>
          2543
        </td>
        <td>
          16427
          -
          16471
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.misc.defaultIfEmpty
        </td>
        <td style="background: #AEF1AE">
          operators.misc.defaultIfEmpty[U](Observable.this, default)
        </td>
      </tr><tr>
        <td>
          373
        </td>
        <td>
          2544
        </td>
        <td>
          16725
          -
          16753
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.take.left
        </td>
        <td style="background: #AEF1AE">
          operators.take.left[T](Observable.this, n)
        </td>
      </tr><tr>
        <td>
          383
        </td>
        <td>
          2545
        </td>
        <td>
          17101
          -
          17146
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.take.leftByTimespan
        </td>
        <td style="background: #AEF1AE">
          operators.take.leftByTimespan[T](Observable.this, timespan)
        </td>
      </tr><tr>
        <td>
          390
        </td>
        <td>
          2546
        </td>
        <td>
          17301
          -
          17330
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.take.right
        </td>
        <td style="background: #AEF1AE">
          operators.take.right[T](Observable.this, n)
        </td>
      </tr><tr>
        <td>
          400
        </td>
        <td>
          2547
        </td>
        <td>
          17600
          -
          17631
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.drop.byCount
        </td>
        <td style="background: #AEF1AE">
          operators.drop.byCount[T](Observable.this, n)
        </td>
      </tr><tr>
        <td>
          410
        </td>
        <td>
          2548
        </td>
        <td>
          17972
          -
          18013
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.drop.byTimespan
        </td>
        <td style="background: #AEF1AE">
          operators.drop.byTimespan[T](Observable.this, timespan)
        </td>
      </tr><tr>
        <td>
          417
        </td>
        <td>
          2549
        </td>
        <td>
          18211
          -
          18246
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.drop.byPredicate
        </td>
        <td style="background: #AEF1AE">
          operators.drop.byPredicate[T](Observable.this)(p)
        </td>
      </tr><tr>
        <td>
          426
        </td>
        <td>
          2550
        </td>
        <td>
          18608
          -
          18652
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.drop.byPredicateWithIndex
        </td>
        <td style="background: #AEF1AE">
          operators.drop.byPredicateWithIndex[T](Observable.this)(p)
        </td>
      </tr><tr>
        <td>
          434
        </td>
        <td>
          2551
        </td>
        <td>
          18853
          -
          18888
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.take.byPredicate
        </td>
        <td style="background: #AEF1AE">
          operators.take.byPredicate[T](Observable.this)(p)
        </td>
      </tr><tr>
        <td>
          441
        </td>
        <td>
          2552
        </td>
        <td>
          19104
          -
          19148
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.take.takeWhileNotCanceled
        </td>
        <td style="background: #AEF1AE">
          operators.take.takeWhileNotCanceled[T](Observable.this, c)
        </td>
      </tr><tr>
        <td>
          452
        </td>
        <td>
          2553
        </td>
        <td>
          19488
          -
          19514
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.math.count
        </td>
        <td style="background: #AEF1AE">
          operators.math.count[T](Observable.this)
        </td>
      </tr><tr>
        <td>
          469
        </td>
        <td>
          2554
        </td>
        <td>
          20089
          -
          20124
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.buffer.sized
        </td>
        <td style="background: #AEF1AE">
          operators.buffer.sized[T](Observable.this, count)
        </td>
      </tr><tr>
        <td>
          482
        </td>
        <td>
          2555
        </td>
        <td>
          20650
          -
          20688
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.buffer.timed
        </td>
        <td style="background: #AEF1AE">
          operators.buffer.timed[T](Observable.this, timespan)
        </td>
      </tr><tr>
        <td>
          497
        </td>
        <td>
          2556
        </td>
        <td>
          21343
          -
          21398
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.buffer.sizedAndTimed
        </td>
        <td style="background: #AEF1AE">
          operators.buffer.sizedAndTimed[T](Observable.this, maxSize, timespan)
        </td>
      </tr><tr>
        <td>
          517
        </td>
        <td>
          2557
        </td>
        <td>
          22298
          -
          22318
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.sample
        </td>
        <td style="background: #AEF1AE">
          Observable.this.sample(delay, delay)
        </td>
      </tr><tr>
        <td>
          539
        </td>
        <td>
          2558
        </td>
        <td>
          23328
          -
          23376
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.sample.once
        </td>
        <td style="background: #AEF1AE">
          operators.sample.once[T](Observable.this, initialDelay, delay)
        </td>
      </tr><tr>
        <td>
          555
        </td>
        <td>
          2559
        </td>
        <td>
          24076
          -
          24104
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.sampleRepeated
        </td>
        <td style="background: #AEF1AE">
          Observable.this.sampleRepeated(delay, delay)
        </td>
      </tr><tr>
        <td>
          573
        </td>
        <td>
          2560
        </td>
        <td>
          24915
          -
          24967
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.sample.repeated
        </td>
        <td style="background: #AEF1AE">
          operators.sample.repeated[T](Observable.this, initialDelay, delay)
        </td>
      </tr><tr>
        <td>
          589
        </td>
        <td>
          2561
        </td>
        <td>
          25635
          -
          25674
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.debounce.apply
        </td>
        <td style="background: #AEF1AE">
          operators.debounce.apply[T](Observable.this, timeout)
        </td>
      </tr><tr>
        <td>
          600
        </td>
        <td>
          2562
        </td>
        <td>
          26100
          -
          26150
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.delaySubscription.onFuture
        </td>
        <td style="background: #AEF1AE">
          operators.delaySubscription.onFuture[T](Observable.this, future)
        </td>
      </tr><tr>
        <td>
          610
        </td>
        <td>
          2563
        </td>
        <td>
          26474
          -
          26528
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.delaySubscription.onTimespan
        </td>
        <td style="background: #AEF1AE">
          operators.delaySubscription.onTimespan[T](Observable.this, timespan)
        </td>
      </tr><tr>
        <td>
          618
        </td>
        <td>
          2564
        </td>
        <td>
          26800
          -
          26837
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.foldLeft.apply
        </td>
        <td style="background: #AEF1AE">
          operators.foldLeft.apply[T, R](Observable.this, initial)(op)
        </td>
      </tr><tr>
        <td>
          626
        </td>
        <td>
          2565
        </td>
        <td>
          27100
          -
          27142
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.reduce.apply
        </td>
        <td style="background: #AEF1AE">
          operators.reduce.apply[U]((Observable.this: monifu.reactive.Observable[U]))(op)
        </td>
      </tr><tr>
        <td>
          637
        </td>
        <td>
          2566
        </td>
        <td>
          27541
          -
          27574
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.scan.apply
        </td>
        <td style="background: #AEF1AE">
          operators.scan.apply[T, R](Observable.this, initial)(op)
        </td>
      </tr><tr>
        <td>
          648
        </td>
        <td>
          2567
        </td>
        <td>
          27987
          -
          28024
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.flatScan.apply
        </td>
        <td style="background: #AEF1AE">
          operators.flatScan.apply[T, R](Observable.this, initial)(op)
        </td>
      </tr><tr>
        <td>
          659
        </td>
        <td>
          2568
        </td>
        <td>
          28457
          -
          28505
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.flatScan.delayError
        </td>
        <td style="background: #AEF1AE">
          operators.flatScan.delayError[T, R](Observable.this, initial)(op)
        </td>
      </tr><tr>
        <td>
          668
        </td>
        <td>
          2569
        </td>
        <td>
          28757
          -
          28794
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.doWork.onComplete
        </td>
        <td style="background: #AEF1AE">
          operators.doWork.onComplete[T](Observable.this)(cb)
        </td>
      </tr><tr>
        <td>
          677
        </td>
        <td>
          2570
        </td>
        <td>
          29068
          -
          29101
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.doWork.onNext
        </td>
        <td style="background: #AEF1AE">
          operators.doWork.onNext[T](Observable.this)(cb)
        </td>
      </tr><tr>
        <td>
          686
        </td>
        <td>
          2571
        </td>
        <td>
          29437
          -
          29471
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.doWork.onStart
        </td>
        <td style="background: #AEF1AE">
          operators.doWork.onStart[T](Observable.this)(cb)
        </td>
      </tr><tr>
        <td>
          693
        </td>
        <td>
          2572
        </td>
        <td>
          29631
          -
          29668
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.doWork.onCanceled
        </td>
        <td style="background: #AEF1AE">
          operators.doWork.onCanceled[T](Observable.this)(cb)
        </td>
      </tr><tr>
        <td>
          704
        </td>
        <td>
          2573
        </td>
        <td>
          30084
          -
          30118
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.doWork.onError
        </td>
        <td style="background: #AEF1AE">
          operators.doWork.onError[T](Observable.this)(cb)
        </td>
      </tr><tr>
        <td>
          713
        </td>
        <td>
          2574
        </td>
        <td>
          30527
          -
          30541
        </td>
        <td>
          Select
        </td>
        <td>
          monifu.reactive.Observable.head
        </td>
        <td style="background: #F0ADAD">
          Observable.this.filter(p).head
        </td>
      </tr><tr>
        <td>
          723
        </td>
        <td>
          2577
        </td>
        <td>
          31012
          -
          31051
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.foldLeft
        </td>
        <td style="background: #F0ADAD">
          Observable.this.find(p).foldLeft[Boolean](false)(((x$1: Boolean, x$2: T) =&gt; true))
        </td>
      </tr><tr>
        <td>
          723
        </td>
        <td>
          2576
        </td>
        <td>
          31046
          -
          31050
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #F0ADAD">
          true
        </td>
      </tr><tr>
        <td>
          723
        </td>
        <td>
          2575
        </td>
        <td>
          31029
          -
          31034
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #F0ADAD">
          false
        </td>
      </tr><tr>
        <td>
          730
        </td>
        <td>
          2578
        </td>
        <td>
          31206
          -
          31234
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.misc.isEmpty
        </td>
        <td style="background: #AEF1AE">
          operators.misc.isEmpty[T](Observable.this)
        </td>
      </tr><tr>
        <td>
          737
        </td>
        <td>
          2580
        </td>
        <td>
          31390
          -
          31443
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.map
        </td>
        <td style="background: #AEF1AE">
          operators.misc.isEmpty[T](Observable.this).map[Boolean](((isEmpty: Boolean) =&gt; isEmpty.unary_!))
        </td>
      </tr><tr>
        <td>
          737
        </td>
        <td>
          2579
        </td>
        <td>
          31434
          -
          31442
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Boolean.unary_!
        </td>
        <td style="background: #AEF1AE">
          isEmpty.unary_!
        </td>
      </tr><tr>
        <td>
          747
        </td>
        <td>
          2583
        </td>
        <td>
          31982
          -
          32013
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.map
        </td>
        <td style="background: #F0ADAD">
          Observable.this.exists(((e: T) =&gt; p.apply(e).unary_!)).map[Boolean](((r: Boolean) =&gt; r.unary_!))
        </td>
      </tr><tr>
        <td>
          747
        </td>
        <td>
          2582
        </td>
        <td>
          32010
          -
          32012
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Boolean.unary_!
        </td>
        <td style="background: #F0ADAD">
          r.unary_!
        </td>
      </tr><tr>
        <td>
          747
        </td>
        <td>
          2581
        </td>
        <td>
          31994
          -
          31999
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Boolean.unary_!
        </td>
        <td style="background: #F0ADAD">
          p.apply(e).unary_!
        </td>
      </tr><tr>
        <td>
          754
        </td>
        <td>
          2584
        </td>
        <td>
          32186
          -
          32215
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.misc.complete
        </td>
        <td style="background: #AEF1AE">
          operators.misc.complete[T](this)
        </td>
      </tr><tr>
        <td>
          762
        </td>
        <td>
          2585
        </td>
        <td>
          32435
          -
          32461
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.misc.error
        </td>
        <td style="background: #AEF1AE">
          operators.misc.error[T](this)
        </td>
      </tr><tr>
        <td>
          770
        </td>
        <td>
          2586
        </td>
        <td>
          32705
          -
          32745
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.misc.endWithError
        </td>
        <td style="background: #AEF1AE">
          operators.misc.endWithError[T](this)(error)
        </td>
      </tr><tr>
        <td>
          777
        </td>
        <td>
          2587
        </td>
        <td>
          32939
          -
          32968
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.++
        </td>
        <td style="background: #F0ADAD">
          Observable.unit[U](elem).++[U](this)
        </td>
      </tr><tr>
        <td>
          784
        </td>
        <td>
          2588
        </td>
        <td>
          33172
          -
          33210
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.++
        </td>
        <td style="background: #F0ADAD">
          Observable.fromIterable[U](elems).++[U](this)
        </td>
      </tr><tr>
        <td>
          791
        </td>
        <td>
          2589
        </td>
        <td>
          33417
          -
          33438
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.unit
        </td>
        <td style="background: #F0ADAD">
          Observable.unit[U](elem)
        </td>
      </tr><tr>
        <td>
          791
        </td>
        <td>
          2590
        </td>
        <td>
          33409
          -
          33438
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.++
        </td>
        <td style="background: #F0ADAD">
          this.++[U](Observable.unit[U](elem))
        </td>
      </tr><tr>
        <td>
          798
        </td>
        <td>
          2592
        </td>
        <td>
          33645
          -
          33683
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.++
        </td>
        <td style="background: #F0ADAD">
          this.++[U](Observable.fromIterable[U](elems))
        </td>
      </tr><tr>
        <td>
          798
        </td>
        <td>
          2591
        </td>
        <td>
          33653
          -
          33683
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.fromIterable
        </td>
        <td style="background: #F0ADAD">
          Observable.fromIterable[U](elems)
        </td>
      </tr><tr>
        <td>
          804
        </td>
        <td>
          2593
        </td>
        <td>
          33841
          -
          33871
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.concat
        </td>
        <td style="background: #AEF1AE">
          Observable.concat[U](this, other)
        </td>
      </tr><tr>
        <td>
          809
        </td>
        <td>
          2594
        </td>
        <td>
          34021
          -
          34028
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.take
        </td>
        <td style="background: #AEF1AE">
          Observable.this.take(1)
        </td>
      </tr><tr>
        <td>
          814
        </td>
        <td>
          2595
        </td>
        <td>
          34144
          -
          34151
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.drop
        </td>
        <td style="background: #F0ADAD">
          Observable.this.drop(1)
        </td>
      </tr><tr>
        <td>
          820
        </td>
        <td>
          2596
        </td>
        <td>
          34304
          -
          34316
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.takeRight
        </td>
        <td style="background: #F0ADAD">
          Observable.this.takeRight(1)
        </td>
      </tr><tr>
        <td>
          827
        </td>
        <td>
          2598
        </td>
        <td>
          34590
          -
          34600
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Some.apply
        </td>
        <td style="background: #F0ADAD">
          scala.Some.apply[T](elem)
        </td>
      </tr><tr>
        <td>
          827
        </td>
        <td>
          2597
        </td>
        <td>
          34560
          -
          34575
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Option.empty
        </td>
        <td style="background: #F0ADAD">
          scala.Option.empty[B]
        </td>
      </tr><tr>
        <td>
          827
        </td>
        <td>
          2599
        </td>
        <td>
          34546
          -
          34670
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.map
        </td>
        <td style="background: #F0ADAD">
          Observable.this.head.foldLeft[Option[B]](scala.Option.empty[B])(((x$3: Option[B], elem: T) =&gt; scala.Some.apply[T](elem))).map[B](((x0$1: Option[B]) =&gt; x0$1 match {
  case (x: B)Some[B]((elem @ _)) =&gt; elem
  case scala.None =&gt; default
}))
        </td>
      </tr><tr>
        <td>
          839
        </td>
        <td>
          2600
        </td>
        <td>
          34935
          -
          34954
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.headOrElse
        </td>
        <td style="background: #F0ADAD">
          Observable.this.headOrElse[U](default)
        </td>
      </tr><tr>
        <td>
          847
        </td>
        <td>
          2601
        </td>
        <td>
          35270
          -
          35296
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.zip.apply
        </td>
        <td style="background: #AEF1AE">
          operators.zip.apply[T, U](Observable.this, other)
        </td>
      </tr><tr>
        <td>
          858
        </td>
        <td>
          2603
        </td>
        <td>
          35806
          -
          35863
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.combineLatest.apply
        </td>
        <td style="background: #AEF1AE">
          operators.combineLatest.apply[T, U](Observable.this, other, false)
        </td>
      </tr><tr>
        <td>
          858
        </td>
        <td>
          2602
        </td>
        <td>
          35857
          -
          35862
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #AEF1AE">
          false
        </td>
      </tr><tr>
        <td>
          868
        </td>
        <td>
          2604
        </td>
        <td>
          36316
          -
          36320
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #AEF1AE">
          true
        </td>
      </tr><tr>
        <td>
          868
        </td>
        <td>
          2605
        </td>
        <td>
          36265
          -
          36321
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.combineLatest.apply
        </td>
        <td style="background: #AEF1AE">
          operators.combineLatest.apply[T, U](Observable.this, other, true)
        </td>
      </tr><tr>
        <td>
          875
        </td>
        <td>
          2606
        </td>
        <td>
          36515
          -
          36555
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          monifu.reactive.operators.math.max
        </td>
        <td style="background: #AEF1AE">
          operators.math.max[U]((this: monifu.reactive.Observable[U]))(ev)
        </td>
      </tr><tr>
        <td>
          882
        </td>
        <td>
          2607
        </td>
        <td>
          36804
          -
          36837
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.math.maxBy
        </td>
        <td style="background: #AEF1AE">
          operators.math.maxBy[T, U](this)(f)(ev)
        </td>
      </tr><tr>
        <td>
          889
        </td>
        <td>
          2608
        </td>
        <td>
          37031
          -
          37071
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          monifu.reactive.operators.math.min
        </td>
        <td style="background: #AEF1AE">
          operators.math.min[U]((this: monifu.reactive.Observable[U]))(ev)
        </td>
      </tr><tr>
        <td>
          896
        </td>
        <td>
          2609
        </td>
        <td>
          37320
          -
          37349
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          monifu.reactive.operators.math.minBy
        </td>
        <td style="background: #AEF1AE">
          operators.math.minBy[T, U](this)(f)(ev)
        </td>
      </tr><tr>
        <td>
          903
        </td>
        <td>
          2610
        </td>
        <td>
          37555
          -
          37595
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          monifu.reactive.operators.math.sum
        </td>
        <td style="background: #AEF1AE">
          operators.math.sum[U]((this: monifu.reactive.Observable[U]))(ev)
        </td>
      </tr><tr>
        <td>
          911
        </td>
        <td>
          2611
        </td>
        <td>
          37770
          -
          37803
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.distinct.distinct
        </td>
        <td style="background: #AEF1AE">
          operators.distinct.distinct[T](this)
        </td>
      </tr><tr>
        <td>
          920
        </td>
        <td>
          2612
        </td>
        <td>
          38046
          -
          38085
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.distinct.distinctBy
        </td>
        <td style="background: #AEF1AE">
          operators.distinct.distinctBy[T, U](this)(fn)
        </td>
      </tr><tr>
        <td>
          926
        </td>
        <td>
          2613
        </td>
        <td>
          38222
          -
          38259
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.distinct.untilChanged
        </td>
        <td style="background: #AEF1AE">
          operators.distinct.untilChanged[T](this)
        </td>
      </tr><tr>
        <td>
          932
        </td>
        <td>
          2614
        </td>
        <td>
          38411
          -
          38454
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.distinct.untilChangedBy
        </td>
        <td style="background: #AEF1AE">
          operators.distinct.untilChangedBy[T, U](this)(fn)
        </td>
      </tr><tr>
        <td>
          939
        </td>
        <td>
          2616
        </td>
        <td>
          38650
          -
          38679
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.concurrent.Scheduler.execute
        </td>
        <td style="background: #F0ADAD">
          s.execute(Observable.this.unsafeSubscribe(o))
        </td>
      </tr><tr>
        <td>
          939
        </td>
        <td>
          2615
        </td>
        <td>
          38660
          -
          38678
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.unsafeSubscribe
        </td>
        <td style="background: #F0ADAD">
          Observable.this.unsafeSubscribe(o)
        </td>
      </tr><tr>
        <td>
          939
        </td>
        <td>
          2617
        </td>
        <td>
          38627
          -
          38680
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.create
        </td>
        <td style="background: #F0ADAD">
          Observable.create[T](((o: monifu.reactive.Subscriber[T]) =&gt; s.execute(Observable.this.unsafeSubscribe(o))))
        </td>
      </tr><tr>
        <td>
          951
        </td>
        <td>
          2618
        </td>
        <td>
          39061
          -
          39088
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.materialize.apply
        </td>
        <td style="background: #AEF1AE">
          operators.materialize.apply[T](Observable.this)
        </td>
      </tr><tr>
        <td>
          957
        </td>
        <td>
          2619
        </td>
        <td>
          39235
          -
          39274
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.debug.dump
        </td>
        <td style="background: #AEF1AE">
          operators.debug.dump[T](Observable.this, prefix, out)
        </td>
      </tr><tr>
        <td>
          964
        </td>
        <td>
          2620
        </td>
        <td>
          39495
          -
          39517
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.repeat.apply
        </td>
        <td style="background: #AEF1AE">
          operators.repeat.apply[T](Observable.this)
        </td>
      </tr><tr>
        <td>
          971
        </td>
        <td>
          2621
        </td>
        <td>
          39793
          -
          39829
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          monifu.reactive.ConnectableObservable.apply
        </td>
        <td style="background: #F0ADAD">
          ConnectableObservable.apply[T, R](this, subject)(s)
        </td>
      </tr><tr>
        <td>
          992
        </td>
        <td>
          2625
        </td>
        <td>
          40998
          -
          41152
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.create
        </td>
        <td style="background: #F0ADAD">
          Observable.create[U](((subscriber: monifu.reactive.Subscriber[U]) =&gt; {
  implicit val s: monifu.concurrent.Scheduler = subscriber.scheduler;
  Observable.this.unsafeSubscribe(monifu.reactive.observers.BufferedSubscriber.apply[U](subscriber.observer, policy)(s))
}))
        </td>
      </tr><tr>
        <td>
          993
        </td>
        <td>
          2622
        </td>
        <td>
          41055
          -
          41075
        </td>
        <td>
          Select
        </td>
        <td>
          monifu.reactive.Subscriber.scheduler
        </td>
        <td style="background: #F0ADAD">
          subscriber.scheduler
        </td>
      </tr><tr>
        <td>
          994
        </td>
        <td>
          2624
        </td>
        <td>
          41082
          -
          41146
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.unsafeSubscribe
        </td>
        <td style="background: #F0ADAD">
          Observable.this.unsafeSubscribe(monifu.reactive.observers.BufferedSubscriber.apply[U](subscriber.observer, policy)(s))
        </td>
      </tr><tr>
        <td>
          994
        </td>
        <td>
          2623
        </td>
        <td>
          41098
          -
          41145
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          monifu.reactive.observers.BufferedSubscriber.apply
        </td>
        <td style="background: #F0ADAD">
          monifu.reactive.observers.BufferedSubscriber.apply[U](subscriber.observer, policy)(s)
        </td>
      </tr><tr>
        <td>
          1001
        </td>
        <td>
          2626
        </td>
        <td>
          41284
          -
          41320
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.whileBusy.dropEvents
        </td>
        <td style="background: #AEF1AE">
          operators.whileBusy.dropEvents[T](Observable.this)
        </td>
      </tr><tr>
        <td>
          1016
        </td>
        <td>
          2627
        </td>
        <td>
          42007
          -
          42073
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.whileBusy.dropEventsThenSignalOverflow
        </td>
        <td style="background: #AEF1AE">
          operators.whileBusy.dropEventsThenSignalOverflow[U](Observable.this, onOverflow)
        </td>
      </tr><tr>
        <td>
          1023
        </td>
        <td>
          2628
        </td>
        <td>
          42273
          -
          42323
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.whileBusy.bufferEvents
        </td>
        <td style="background: #AEF1AE">
          operators.whileBusy.bufferEvents[T](Observable.this, bufferSize)
        </td>
      </tr><tr>
        <td>
          1031
        </td>
        <td>
          2629
        </td>
        <td>
          42670
          -
          42697
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          monifu.reactive.Observable.multicast
        </td>
        <td style="background: #F0ADAD">
          Observable.this.multicast[T](monifu.reactive.subjects.PublishSubject.apply[T]())(s)
        </td>
      </tr><tr>
        <td>
          1039
        </td>
        <td>
          2630
        </td>
        <td>
          43070
          -
          43110
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          monifu.reactive.Observable.multicast
        </td>
        <td style="background: #F0ADAD">
          Observable.this.multicast[U](monifu.reactive.subjects.BehaviorSubject.apply[U](initialValue))(s)
        </td>
      </tr><tr>
        <td>
          1047
        </td>
        <td>
          2631
        </td>
        <td>
          43454
          -
          43480
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          monifu.reactive.Observable.multicast
        </td>
        <td style="background: #F0ADAD">
          Observable.this.multicast[T](monifu.reactive.subjects.ReplaySubject.apply[T]())(s)
        </td>
      </tr><tr>
        <td>
          1055
        </td>
        <td>
          2632
        </td>
        <td>
          43827
          -
          43852
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          monifu.reactive.Observable.multicast
        </td>
        <td style="background: #F0ADAD">
          Observable.this.multicast[T](monifu.reactive.subjects.AsyncSubject.apply[T]())(s)
        </td>
      </tr><tr>
        <td>
          1076
        </td>
        <td>
          2633
        </td>
        <td>
          44732
          -
          44771
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.onError.recoverWith
        </td>
        <td style="background: #AEF1AE">
          operators.onError.recoverWith[U](Observable.this, pf)
        </td>
      </tr><tr>
        <td>
          1095
        </td>
        <td>
          2634
        </td>
        <td>
          45498
          -
          45538
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.onError.fallbackTo
        </td>
        <td style="background: #AEF1AE">
          operators.onError.fallbackTo[U](Observable.this, that)
        </td>
      </tr><tr>
        <td>
          1108
        </td>
        <td>
          2635
        </td>
        <td>
          46004
          -
          46042
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.onError.retryUnlimited
        </td>
        <td style="background: #AEF1AE">
          operators.onError.retryUnlimited[T](Observable.this)
        </td>
      </tr><tr>
        <td>
          1122
        </td>
        <td>
          2636
        </td>
        <td>
          46584
          -
          46632
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.onError.retryCounted
        </td>
        <td style="background: #AEF1AE">
          operators.onError.retryCounted[T](Observable.this, maxRetries)
        </td>
      </tr><tr>
        <td>
          1134
        </td>
        <td>
          2637
        </td>
        <td>
          47047
          -
          47081
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.onError.retryIf
        </td>
        <td style="background: #AEF1AE">
          operators.onError.retryIf[T](Observable.this, p)
        </td>
      </tr><tr>
        <td>
          1147
        </td>
        <td>
          2638
        </td>
        <td>
          47579
          -
          47621
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.timeout.emitError
        </td>
        <td style="background: #AEF1AE">
          operators.timeout.emitError[T](Observable.this, timeout)
        </td>
      </tr><tr>
        <td>
          1162
        </td>
        <td>
          2639
        </td>
        <td>
          48239
          -
          48294
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.operators.timeout.switchToBackup
        </td>
        <td style="background: #F0ADAD">
          operators.timeout.switchToBackup[U](Observable.this, timeout, backup)
        </td>
      </tr><tr>
        <td>
          1169
        </td>
        <td>
          2640
        </td>
        <td>
          48526
          -
          48533
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Function1.apply
        </td>
        <td style="background: #F0ADAD">
          f.apply(Observable.this)
        </td>
      </tr><tr>
        <td>
          1176
        </td>
        <td>
          2641
        </td>
        <td>
          48718
          -
          48738
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.concurrent.Promise.apply
        </td>
        <td style="background: #AEF1AE">
          scala.concurrent.Promise.apply[Option[T]]()
        </td>
      </tr><tr>
        <td>
          1178
        </td>
        <td>
          2642
        </td>
        <td>
          48744
          -
          49027
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          monifu.reactive.Observable.unsafeSubscribe
        </td>
        <td style="background: #AEF1AE">
          Observable.this.head.unsafeSubscribe({
  final class $anon extends AnyRef with monifu.reactive.Observer[T] {
    def &lt;init&gt;(): &lt;$anon: monifu.reactive.Observer[T]&gt; = {
      $anon.super.&lt;init&gt;();
      ()
    };
    def onNext(elem: T): monifu.reactive.Ack.Cancel.type = {
      promise.trySuccess(scala.Some.apply[T](elem));
      monifu.reactive.Ack.Cancel
    };
    def onComplete(): Unit = {
      promise.trySuccess(scala.None);
      ()
    };
    def onError(ex: Throwable): Unit = {
      promise.tryFailure(ex);
      ()
    }
  };
  new $anon()
})(s)
        </td>
      </tr><tr>
        <td>
          1193
        </td>
        <td>
          2643
        </td>
        <td>
          49033
          -
          49047
        </td>
        <td>
          Select
        </td>
        <td>
          scala.concurrent.Promise.future
        </td>
        <td style="background: #AEF1AE">
          promise.future
        </td>
      </tr><tr>
        <td>
          1201
        </td>
        <td>
          2644
        </td>
        <td>
          49251
          -
          49548
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          monifu.reactive.Observable.unsafeSubscribe
        </td>
        <td style="background: #F0ADAD">
          Observable.this.unsafeSubscribe({
  final class $anon extends AnyRef with monifu.reactive.Observer[T] {
    def &lt;init&gt;(): &lt;$anon: monifu.reactive.Observer[T]&gt; = {
      $anon.super.&lt;init&gt;();
      ()
    };
    def onNext(elem: T): scala.concurrent.Future[monifu.reactive.Ack] = try {
      cb.apply(elem);
      monifu.reactive.Ack.Continue
    } catch {
      case scala.util.control.NonFatal.unapply(&lt;unapply-selector&gt;) &lt;unapply&gt; ((ex @ _)) =&gt; {
        $anon.this.onError(ex);
        monifu.reactive.Ack.Cancel
      }
    };
    def onComplete(): Unit = ();
    def onError(ex: Throwable): Unit = s.reportFailure(ex)
  };
  new $anon()
})(s)
        </td>
      </tr><tr>
        <td>
          1255
        </td>
        <td>
          2648
        </td>
        <td>
          50783
          -
          50786
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.$anon.&lt;init&gt;
        </td>
        <td style="background: #AEF1AE">
          new $anon()
        </td>
      </tr><tr>
        <td>
          1257
        </td>
        <td>
          2646
        </td>
        <td>
          50872
          -
          50885
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Function1.apply
        </td>
        <td style="background: #AEF1AE">
          f.apply(subscriber)
        </td>
      </tr><tr>
        <td>
          1257
        </td>
        <td>
          2645
        </td>
        <td>
          50872
          -
          50885
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Function1.apply
        </td>
        <td style="background: #AEF1AE">
          f.apply(subscriber)
        </td>
      </tr><tr>
        <td>
          1259
        </td>
        <td>
          2647
        </td>
        <td>
          50937
          -
          50968
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observer.onError
        </td>
        <td style="background: #F0ADAD">
          subscriber.observer.onError(ex)
        </td>
      </tr><tr>
        <td>
          1271
        </td>
        <td>
          2649
        </td>
        <td>
          51252
          -
          51271
        </td>
        <td>
          Select
        </td>
        <td>
          monifu.reactive.builders.unit.empty
        </td>
        <td style="background: #AEF1AE">
          builders.unit.empty
        </td>
      </tr><tr>
        <td>
          1279
        </td>
        <td>
          2650
        </td>
        <td>
          51494
          -
          51517
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.builders.unit.one
        </td>
        <td style="background: #AEF1AE">
          builders.unit.one[A](elem)
        </td>
      </tr><tr>
        <td>
          1287
        </td>
        <td>
          2651
        </td>
        <td>
          51740
          -
          51763
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.builders.unit.error
        </td>
        <td style="background: #AEF1AE">
          builders.unit.error(ex)
        </td>
      </tr><tr>
        <td>
          1295
        </td>
        <td>
          2652
        </td>
        <td>
          52004
          -
          52023
        </td>
        <td>
          Select
        </td>
        <td>
          monifu.reactive.builders.unit.never
        </td>
        <td style="background: #AEF1AE">
          builders.unit.never
        </td>
      </tr><tr>
        <td>
          1308
        </td>
        <td>
          2653
        </td>
        <td>
          52592
          -
          52631
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.builders.interval.withFixedDelay
        </td>
        <td style="background: #AEF1AE">
          builders.interval.withFixedDelay(delay)
        </td>
      </tr><tr>
        <td>
          1321
        </td>
        <td>
          2654
        </td>
        <td>
          53186
          -
          53215
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.intervalWithFixedDelay
        </td>
        <td style="background: #F0ADAD">
          Observable.this.intervalWithFixedDelay(delay)
        </td>
      </tr><tr>
        <td>
          1345
        </td>
        <td>
          2655
        </td>
        <td>
          54115
          -
          54152
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.builders.interval.atFixedRate
        </td>
        <td style="background: #AEF1AE">
          builders.interval.atFixedRate(period)
        </td>
      </tr><tr>
        <td>
          1351
        </td>
        <td>
          2656
        </td>
        <td>
          54296
          -
          54323
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.builders.repeat.apply
        </td>
        <td style="background: #AEF1AE">
          builders.repeat.apply[T]((elems: _*))
        </td>
      </tr><tr>
        <td>
          1363
        </td>
        <td>
          2657
        </td>
        <td>
          54717
          -
          54750
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.builders.range.apply
        </td>
        <td style="background: #AEF1AE">
          builders.range.apply(from, until, step)
        </td>
      </tr><tr>
        <td>
          1380
        </td>
        <td>
          2658
        </td>
        <td>
          55163
          -
          55182
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.fromIterable
        </td>
        <td style="background: #F0ADAD">
          Observable.this.fromIterable[T](elems)
        </td>
      </tr><tr>
        <td>
          1389
        </td>
        <td>
          2659
        </td>
        <td>
          55415
          -
          55443
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.builders.from.future
        </td>
        <td style="background: #AEF1AE">
          builders.from.future[T](future)
        </td>
      </tr><tr>
        <td>
          1397
        </td>
        <td>
          2660
        </td>
        <td>
          55715
          -
          55747
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.builders.from.iterable
        </td>
        <td style="background: #AEF1AE">
          builders.from.iterable[T](iterable)
        </td>
      </tr><tr>
        <td>
          1405
        </td>
        <td>
          2661
        </td>
        <td>
          55987
          -
          56016
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.builders.from.iterable
        </td>
        <td style="background: #AEF1AE">
          builders.from.iterable[T](elems)
        </td>
      </tr><tr>
        <td>
          1411
        </td>
        <td>
          2662
        </td>
        <td>
          56176
          -
          56213
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.builders.unit.oneDelayed
        </td>
        <td style="background: #AEF1AE">
          builders.unit.oneDelayed[T](delay, unit)
        </td>
      </tr><tr>
        <td>
          1418
        </td>
        <td>
          2663
        </td>
        <td>
          56444
          -
          56495
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.builders.timer.repeated
        </td>
        <td style="background: #AEF1AE">
          builders.timer.repeated[T](initialDelay, period, unit)
        </td>
      </tr><tr>
        <td>
          1424
        </td>
        <td>
          2664
        </td>
        <td>
          56683
          -
          56683
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Predef.$conforms
        </td>
        <td style="background: #F0ADAD">
          scala.this.Predef.$conforms[monifu.reactive.Observable[T]]
        </td>
      </tr><tr>
        <td>
          1424
        </td>
        <td>
          2665
        </td>
        <td>
          56650
          -
          56689
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          monifu.reactive.Observable.concat
        </td>
        <td style="background: #F0ADAD">
          Observable.fromIterable[monifu.reactive.Observable[T]](sources).concat[T](scala.this.Predef.$conforms[monifu.reactive.Observable[T]])
        </td>
      </tr><tr>
        <td>
          1431
        </td>
        <td>
          2667
        </td>
        <td>
          56888
          -
          56937
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          monifu.reactive.Observable.concatDelayError
        </td>
        <td style="background: #F0ADAD">
          Observable.fromIterable[monifu.reactive.Observable[T]](sources).concatDelayError[T](scala.this.Predef.$conforms[monifu.reactive.Observable[T]])
        </td>
      </tr><tr>
        <td>
          1431
        </td>
        <td>
          2666
        </td>
        <td>
          56921
          -
          56921
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Predef.$conforms
        </td>
        <td style="background: #F0ADAD">
          scala.this.Predef.$conforms[monifu.reactive.Observable[T]]
        </td>
      </tr><tr>
        <td>
          1437
        </td>
        <td>
          2670
        </td>
        <td>
          57122
          -
          57122
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Predef.$conforms
        </td>
        <td style="background: #AEF1AE">
          scala.this.Predef.$conforms[monifu.reactive.Observable[T]]
        </td>
      </tr><tr>
        <td>
          1437
        </td>
        <td>
          2669
        </td>
        <td>
          57117
          -
          57117
        </td>
        <td>
          TypeApply
        </td>
        <td>
          monifu.reactive.Observable.merge$default$1
        </td>
        <td style="background: #AEF1AE">
          qual$3.merge$default$1[Nothing]
        </td>
      </tr><tr>
        <td>
          1437
        </td>
        <td>
          2668
        </td>
        <td>
          57084
          -
          57116
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.fromIterable
        </td>
        <td style="background: #AEF1AE">
          Observable.fromIterable[monifu.reactive.Observable[T]](sources)
        </td>
      </tr><tr>
        <td>
          1437
        </td>
        <td>
          2671
        </td>
        <td>
          57084
          -
          57124
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.merge
        </td>
        <td style="background: #AEF1AE">
          qual$3.merge[T](x$6)(scala.this.Predef.$conforms[monifu.reactive.Observable[T]])
        </td>
      </tr><tr>
        <td>
          1444
        </td>
        <td>
          2673
        </td>
        <td>
          57348
          -
          57348
        </td>
        <td>
          TypeApply
        </td>
        <td>
          monifu.reactive.Observable.mergeDelayError$default$1
        </td>
        <td style="background: #F0ADAD">
          qual$4.mergeDelayError$default$1[Nothing]
        </td>
      </tr><tr>
        <td>
          1444
        </td>
        <td>
          2672
        </td>
        <td>
          57315
          -
          57347
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.fromIterable
        </td>
        <td style="background: #F0ADAD">
          Observable.fromIterable[monifu.reactive.Observable[T]](sources)
        </td>
      </tr><tr>
        <td>
          1444
        </td>
        <td>
          2675
        </td>
        <td>
          57315
          -
          57365
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.mergeDelayError
        </td>
        <td style="background: #F0ADAD">
          qual$4.mergeDelayError[T](x$7)(scala.this.Predef.$conforms[monifu.reactive.Observable[T]])
        </td>
      </tr><tr>
        <td>
          1444
        </td>
        <td>
          2674
        </td>
        <td>
          57363
          -
          57363
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Predef.$conforms
        </td>
        <td style="background: #F0ADAD">
          scala.this.Predef.$conforms[monifu.reactive.Observable[T]]
        </td>
      </tr><tr>
        <td>
          1451
        </td>
        <td>
          2676
        </td>
        <td>
          57553
          -
          57553
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Predef.$conforms
        </td>
        <td style="background: #AEF1AE">
          scala.this.Predef.$conforms[monifu.reactive.Observable[T]]
        </td>
      </tr><tr>
        <td>
          1451
        </td>
        <td>
          2677
        </td>
        <td>
          57520
          -
          57559
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          monifu.reactive.Observable.concat
        </td>
        <td style="background: #AEF1AE">
          Observable.fromIterable[monifu.reactive.Observable[T]](sources).concat[T](scala.this.Predef.$conforms[monifu.reactive.Observable[T]])
        </td>
      </tr><tr>
        <td>
          1458
        </td>
        <td>
          2679
        </td>
        <td>
          57757
          -
          57806
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          monifu.reactive.Observable.concatDelayError
        </td>
        <td style="background: #F0ADAD">
          Observable.fromIterable[monifu.reactive.Observable[T]](sources).concatDelayError[T](scala.this.Predef.$conforms[monifu.reactive.Observable[T]])
        </td>
      </tr><tr>
        <td>
          1458
        </td>
        <td>
          2678
        </td>
        <td>
          57790
          -
          57790
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Predef.$conforms
        </td>
        <td style="background: #F0ADAD">
          scala.this.Predef.$conforms[monifu.reactive.Observable[T]]
        </td>
      </tr><tr>
        <td>
          1466
        </td>
        <td>
          2680
        </td>
        <td>
          58121
          -
          58135
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.zip
        </td>
        <td style="background: #AEF1AE">
          obs1.zip[T2](obs2)
        </td>
      </tr><tr>
        <td>
          1474
        </td>
        <td>
          2682
        </td>
        <td>
          58499
          -
          58567
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.map
        </td>
        <td style="background: #F0ADAD">
          obs1.zip[T2](obs2).zip[T3](obs3).map[(T1, T2, T3)](((x0$2: ((T1, T2), T3)) =&gt; x0$2 match {
  case (_1: (T1, T2), _2: T3)((T1, T2), T3)((_1: T1, _2: T2)(T1, T2)((t1 @ _), (t2 @ _)), (t3 @ _)) =&gt; scala.Tuple3.apply[T1, T2, T3](t1, t2, t3)
}))
        </td>
      </tr><tr>
        <td>
          1474
        </td>
        <td>
          2681
        </td>
        <td>
          58553
          -
          58565
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple3.apply
        </td>
        <td style="background: #F0ADAD">
          scala.Tuple3.apply[T1, T2, T3](t1, t2, t3)
        </td>
      </tr><tr>
        <td>
          1482
        </td>
        <td>
          2684
        </td>
        <td>
          58961
          -
          59049
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.map
        </td>
        <td style="background: #F0ADAD">
          obs1.zip[T2](obs2).zip[T3](obs3).zip[T4](obs4).map[(T1, T2, T3, T4)](((x0$3: (((T1, T2), T3), T4)) =&gt; x0$3 match {
  case (_1: ((T1, T2), T3), _2: T4)(((T1, T2), T3), T4)((_1: (T1, T2), _2: T3)((T1, T2), T3)((_1: T1, _2: T2)(T1, T2)((t1 @ _), (t2 @ _)), (t3 @ _)), (t4 @ _)) =&gt; scala.Tuple4.apply[T1, T2, T3, T4](t1, t2, t3, t4)
}))
        </td>
      </tr><tr>
        <td>
          1482
        </td>
        <td>
          2683
        </td>
        <td>
          59031
          -
          59047
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple4.apply
        </td>
        <td style="background: #F0ADAD">
          scala.Tuple4.apply[T1, T2, T3, T4](t1, t2, t3, t4)
        </td>
      </tr><tr>
        <td>
          1493
        </td>
        <td>
          2685
        </td>
        <td>
          59573
          -
          59600
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.combineLatest
        </td>
        <td style="background: #AEF1AE">
          first.combineLatest[T2](second)
        </td>
      </tr><tr>
        <td>
          1508
        </td>
        <td>
          2687
        </td>
        <td>
          60166
          -
          60265
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.map
        </td>
        <td style="background: #F0ADAD">
          first.combineLatest[T2](second).combineLatest[T3](third).map[(T1, T2, T3)](((x0$4: ((T1, T2), T3)) =&gt; x0$4 match {
  case (_1: (T1, T2), _2: T3)((T1, T2), T3)((_1: T1, _2: T2)(T1, T2)((t1 @ _), (t2 @ _)), (t3 @ _)) =&gt; scala.Tuple3.apply[T1, T2, T3](t1, t2, t3)
}))
        </td>
      </tr><tr>
        <td>
          1508
        </td>
        <td>
          2686
        </td>
        <td>
          60251
          -
          60263
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple3.apply
        </td>
        <td style="background: #F0ADAD">
          scala.Tuple3.apply[T1, T2, T3](t1, t2, t3)
        </td>
      </tr><tr>
        <td>
          1524
        </td>
        <td>
          2688
        </td>
        <td>
          60985
          -
          61001
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple4.apply
        </td>
        <td style="background: #F0ADAD">
          scala.Tuple4.apply[T1, T2, T3, T4](t1, t2, t3, t4)
        </td>
      </tr><tr>
        <td>
          1524
        </td>
        <td>
          2689
        </td>
        <td>
          60872
          -
          61003
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.map
        </td>
        <td style="background: #F0ADAD">
          first.combineLatest[T2](second).combineLatest[T3](third).combineLatest[T4](fourth).map[(T1, T2, T3, T4)](((x0$5: (((T1, T2), T3), T4)) =&gt; x0$5 match {
  case (_1: ((T1, T2), T3), _2: T4)(((T1, T2), T3), T4)((_1: (T1, T2), _2: T3)((T1, T2), T3)((_1: T1, _2: T2)(T1, T2)((t1 @ _), (t2 @ _)), (t3 @ _)), (t4 @ _)) =&gt; scala.Tuple4.apply[T1, T2, T3, T4](t1, t2, t3, t4)
}))
        </td>
      </tr><tr>
        <td>
          1532
        </td>
        <td>
          2690
        </td>
        <td>
          61221
          -
          61246
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.builders.amb.apply
        </td>
        <td style="background: #F0ADAD">
          builders.amb.apply[T]((source: _*))
        </td>
      </tr><tr>
        <td>
          1538
        </td>
        <td>
          2691
        </td>
        <td>
          61389
          -
          61418
        </td>
        <td>
          Apply
        </td>
        <td>
          monifu.reactive.Observable.fromFuture
        </td>
        <td style="background: #F0ADAD">
          Observable.fromFuture[T](future)
        </td>
      </tr><tr>
        <td>
          1544
        </td>
        <td>
          2692
        </td>
        <td>
          61593
          -
          61609
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          monifu.reactive.Observable.publisher
        </td>
        <td style="background: #AEF1AE">
          source.publisher[T](s)
        </td>
      </tr>
    </table>
          </div>
        </div>
      </body>
    </html>